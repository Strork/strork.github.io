<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>vim</title>
    <url>/2019/09/27/vim/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">syntax on     <span class="string">"自动语法高亮</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set nu        "</span>显示行号</span><br><span class="line">color desert  <span class="string">"设定配色方案为cpp.vim</span></span><br><span class="line"><span class="string">"</span><span class="built_in">set</span> cursorline <span class="string">" 突出显示当前行</span></span><br><span class="line"><span class="string">set ruler "</span> 打开状态栏标尺</span><br><span class="line"><span class="built_in">set</span> ts=<span class="number">4</span></span><br><span class="line"><span class="built_in">set</span> st=<span class="number">4</span></span><br><span class="line"><span class="built_in">set</span> sw=<span class="number">4</span></span><br><span class="line"><span class="built_in">set</span> smarttab</span><br><span class="line"><span class="built_in">set</span> expandtab</span><br><span class="line"><span class="built_in">set</span> nobackup <span class="string">" 覆盖文件时不备份</span></span><br><span class="line"><span class="string">set noundofile</span></span><br><span class="line"><span class="string">"</span><span class="built_in">set</span> noswapfile</span><br><span class="line"><span class="built_in">set</span> autoindent</span><br><span class="line"><span class="built_in">set</span> cindent</span><br><span class="line"><span class="built_in">set</span> guifont=Consolas:h19</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>【洛谷p3690】Link Cut Tree</title>
    <url>/2019/03/24/luogu3690/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>给定n个点以及每个点的权值，要你处理接下来的m个操作。操作有4种。操作从0到3编号。点从1到n编号。</p>
<p>0：后接两个整数(x，y)，代表询问从x到y的路径上的点的权值的xor和。保证x到y是联通的。</p>
<p>1：后接两个整数(x，y)，代表连接x到y，若x到y已经联通则无需连接。</p>
<p>2：后接两个整数(x，y)，代表删除边(x，y)，不保证边(x，y)存在。</p>
<p>3：后接两个整数(x，y)，代表将点x上的权值变成y。</p>
</blockquote><a id="more"></a>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><blockquote>
<p>第1行两个整数，分别为n和m，代表点数和操作数。</p>
<p>第2行到第n+1行，每行一个整数，整数在［1，10^9］内，代表每个点的权值。</p>
<p>第n+2行到第n+m+1行，每行三个整数，分别代表操作类型和操作所需的量。</p>
</blockquote>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><blockquote>
<p>对于每一个0号操作，你须输出x到y的路径上点权的xor和。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>3 3<br>1<br>2<br>3<br>1 1 2<br>0 1 2<br>0 1 1</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>3<br>1</p>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>LCT板子…需要注意的是rotate过程的变化，splay过程的变化</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc(x) c[x][0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc(x) c[x][1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c[<span class="number">300100</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">300100</span>];</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">300100</span>];</span><br><span class="line"><span class="keyword">int</span> st[<span class="number">300100</span>];</span><br><span class="line"><span class="keyword">bool</span> rev[<span class="number">300100</span>];</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">300100</span>];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>; ch = getchar(); &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; k = k * <span class="number">10</span> + ch - <span class="string">'0'</span>; ch = getchar(); &#125;</span><br><span class="line">    <span class="keyword">return</span> k * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">revers</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    swap(lc(x), rc(x));</span><br><span class="line">    rev[x] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    ans[x] = ans[lc(x)] ^ ans[rc(x)] ^ v[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rev[x]) &#123;</span><br><span class="line">        rev[x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (lc(x)) revers(lc(x));</span><br><span class="line">        <span class="keyword">if</span> (rc(x)) revers(rc(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">son</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == c[fa[x]][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    c[x][z] = y;</span><br><span class="line">    fa[y] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">noroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c[fa[x]][<span class="number">0</span>] == x || c[fa[x]][<span class="number">1</span>] == x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f = fa[x]; <span class="comment">//cout&lt;&lt;f;</span></span><br><span class="line">    <span class="keyword">bool</span> flag = son(x);</span><br><span class="line">    <span class="keyword">if</span> (noroot(f)) ins(fa[f], x, son(f));</span><br><span class="line">    <span class="keyword">else</span> fa[x] = fa[f];</span><br><span class="line">    ins(f, c[x][flag^<span class="number">1</span>], flag);</span><br><span class="line">    ins(x, f, flag^<span class="number">1</span>);</span><br><span class="line">    pushup(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    st[++tot] = x;</span><br><span class="line">    <span class="keyword">int</span> t = x;</span><br><span class="line">    <span class="keyword">while</span> (noroot(t)) &#123;</span><br><span class="line">        t = fa[t];</span><br><span class="line">        st[++tot] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (tot) pushdown(st[tot--]);</span><br><span class="line">    <span class="keyword">while</span> (noroot(x)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (noroot(fa[x])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (son(x) == son(fa[x])) rotate(fa[x]);</span><br><span class="line">            <span class="keyword">else</span> rotate(x);</span><br><span class="line">        &#125;</span><br><span class="line">        rotate(x);</span><br><span class="line">    &#125;</span><br><span class="line">    pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (reg y = <span class="number">0</span>; x; x = fa[x]) &#123;</span><br><span class="line">        splay(x);</span><br><span class="line">        rc(x) = y;</span><br><span class="line">        pushup(x);</span><br><span class="line">        y = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">makeroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    access(x);</span><br><span class="line">    splay(x);</span><br><span class="line">    revers(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    access(x);</span><br><span class="line">    splay(x);</span><br><span class="line">    <span class="keyword">while</span> (lc(x)) &#123;</span><br><span class="line">        pushdown(x);</span><br><span class="line">        x = lc(x);</span><br><span class="line">    &#125;</span><br><span class="line">    splay(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    makeroot(x);</span><br><span class="line">    access(y);</span><br><span class="line">    splay(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addlink</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    makeroot(x);</span><br><span class="line">    <span class="keyword">if</span> (findroot(y) != x) fa[x] = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    makeroot(x);</span><br><span class="line">    <span class="keyword">if</span> (findroot(y) != x || fa[y] != x || c[y][<span class="number">0</span>]) <span class="keyword">return</span>;</span><br><span class="line">    fa[y] = c[x][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = read(); m = read();</span><br><span class="line">    <span class="keyword">for</span> (reg i = <span class="number">1</span>; i &lt;= n; ++i) v[i] = read();</span><br><span class="line">    <span class="keyword">for</span> (reg i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> op = read();</span><br><span class="line">        <span class="keyword">int</span> x = read(), y = read();</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">0</span>) &#123; split(x, y); <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[y]); &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">1</span>) addlink(x, y);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) cut(x, y);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>) &#123; splay(x); v[x] = y; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>动态树</category>
        <category>LCT</category>
      </categories>
      <tags>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title>代码模板Template</title>
    <url>/2019/03/12/template/</url>
    <content><![CDATA[<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="扩展欧几里德算法"><a href="#扩展欧几里德算法" class="headerlink" title="扩展欧几里德算法"></a>扩展欧几里德算法</h3><p>贝祖定理：对于任意整数$a,b$，存在一对整数$x,y$满足$ax+by=gcd(a,b)$。</p><a id="more"></a>
<p>证明：</p>
<ul>
<li><p>显然，存在$x=1,y=0$使得$ xa + by = gcd (a , b)$成立</p>
</li>
<li><p>若$b&gt;0$，则有$gcd(a,b)=gcd(b,a \mod b)$。</p>
</li>
<li><p>假设存在一对整数$x,y$使得$bx+(a \mod b)y=gcd(b,a \mod b)$</p>
</li>
<li><p>$bx+(a \mod b)y=bx+(a-b(\frac ab))*y=ay+b(x-y(\frac ab))$</p>
</li>
<li><p>令$x’=y,y’=x-y(\frac ab)$，则$ax’+by’=gcd(a,b)$</p>
</li>
<li><p>对欧几里德算法的递归过程进行数学归纳，可知定理成立</p>
</li>
</ul>
<p>贝祖定理是按照欧几里德算法的思路证明的，且同时给出了$x,y$的计算方法。我们称其为扩展欧几里德算法。</p>
<p><strong>Code</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span>; y = <span class="number">0</span>; <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll r = exgcd(b, a % b, x, y);</span><br><span class="line">    ll t = x; x = y; y = t - a / b * y;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述程序可求$ax+by=gcd(a,b)$的一组特解$x_0,y_0$，并返回最大公约数$r$。</p>
<p>对于一般方程$ax+by=c$，它有解当且仅当$r|c$。我们对特解$x_0,y_0$同时乘上$\frac cr$，即可得到一组特解$\frac crx_0,\frac cry_0$。</p>
<p>由此我们可得通解$x=\frac crx_0+k\frac br,y=\frac cry_0-k\frac ar(k\in Z)$</p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="二分优化的lis"><a href="#二分优化的lis" class="headerlink" title="二分优化的lis"></a>二分优化的lis</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> f[<span class="number">300100</span>];</span><br><span class="line"><span class="keyword">int</span> g[<span class="number">300100</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">300100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lf = <span class="number">0</span>, rt = k, mid;</span><br><span class="line">    <span class="keyword">while</span> (lf + <span class="number">1</span> &lt; rt) &#123;</span><br><span class="line">        mid = ((lf + rt) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (g[mid] &lt; x) lf = mid;</span><br><span class="line">        <span class="keyword">else</span> rt = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (g[rt] &lt; x) lf = rt;</span><br><span class="line">    <span class="keyword">return</span> lf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    g[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">    k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; g[k]) &#123;</span><br><span class="line">            k++;</span><br><span class="line">            g[k] = a[i];</span><br><span class="line">            f[i] = k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> t = binary(a[i]);</span><br><span class="line">            f[i] = t + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (g[t + <span class="number">1</span>] &gt; a[i]) g[t + <span class="number">1</span>] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h3 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h3><h4 id="堆优化的dijkstra"><a href="#堆优化的dijkstra" class="headerlink" title="堆优化的dijkstra"></a>堆优化的dijkstra</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;pii, <span class="built_in">vector</span>&lt;pii&gt;, greater&lt;pii&gt; &gt; Q;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">10</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    Q.push(make_pair(dis[s], s));</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">        pii temp = Q.top();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">int</span> x = temp.second;</span><br><span class="line">        <span class="keyword">if</span> (vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lin[x]; i; i = e[i].nt) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[e[i].y] &gt; dis[x] + e[i].v) &#123;</span><br><span class="line">                dis[e[i].y] = dis[x] + e[i].v;</span><br><span class="line">                Q.push(make_pair(dis[e[i].y], e[i].y));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Tarjan"><a href="#Tarjan" class="headerlink" title="Tarjan"></a>Tarjan</h3><h4 id="强连通分量缩点"><a href="#强连通分量缩点" class="headerlink" title="强连通分量缩点"></a>强连通分量缩点</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++tim;</span><br><span class="line">    vis[<span class="built_in">stack</span>[++top] = x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lin[x]; i; i = e[i].nt) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = e[i].y;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[y]) &#123;</span><br><span class="line">            tarjan(y);</span><br><span class="line">            low[x] = <span class="built_in">std</span>::min(low[x], low[y]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (vis[y]) low[x] = <span class="built_in">std</span>::min(low[x], dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (low[x] == dfn[x]) &#123;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        ++num;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            k = <span class="built_in">stack</span>[top--];</span><br><span class="line">            bel[k] = num;</span><br><span class="line">            vis[k] = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (k != x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="割点"><a href="#割点" class="headerlink" title="割点"></a>割点</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> father = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    dfn[x] = low[x] = ++tim;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lin[x]; i; i = e[i].nt) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = e[i].y;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[y]) &#123;</span><br><span class="line">            tarjan(y, x);</span><br><span class="line">            low[x] = <span class="built_in">std</span>::min(low[x], low[y]);</span><br><span class="line">            <span class="keyword">if</span> (low[y] &gt;= dfn[x]) ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[x] = <span class="built_in">std</span>::min(low[x], dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt &gt;= <span class="number">2</span> || (father &amp;&amp; cnt == <span class="number">1</span>)) ans[++tail] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="割边"><a href="#割边" class="headerlink" title="割边"></a>割边</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> par = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++tim;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lin[x]; i; i = e[i].nt) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = e[i].y;</span><br><span class="line">        <span class="keyword">if</span> (i != par) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfn[y]) &#123;</span><br><span class="line">                tarjan(y, rev[i]);</span><br><span class="line">                low[x] = min(low[x], low[y]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> low[x] = min(low[x], dfn[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dfn[x] == low[x]) ans[++tail] = par;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h3><h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    f[id] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (id == n) &#123;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">        ans += v;</span><br><span class="line">        fwd = v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[id][i] &gt; <span class="number">0</span> &amp;&amp; !f[i]) &#123;</span><br><span class="line">            dfs(i, <span class="built_in">std</span>::min(v, a[id][i]));</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                a[id][i] -= fwd;</span><br><span class="line">                a[i][id] += fwd;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">        dfs(<span class="number">1</span>, oo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Dinic"><a href="#Dinic" class="headerlink" title="Dinic"></a>Dinic</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">make_level</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(level, <span class="number">-1</span>, <span class="keyword">sizeof</span>(level));</span><br><span class="line">    level[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    head = <span class="number">0</span>;</span><br><span class="line">    tail = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (head++ &lt; tail) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q[head];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lin[x]; i; i = e[i].nt) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e[i].v &amp;&amp; level[e[i].y] == <span class="number">-1</span>) &#123;</span><br><span class="line">                q[++tail] = e[i].y;</span><br><span class="line">                level[e[i].y] = level[x] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level[n*m] &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_flow</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> flow)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == n*m) <span class="keyword">return</span> flow;</span><br><span class="line">    <span class="keyword">int</span> maxflow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lin[k]; i &amp;&amp; (maxflow &lt; flow); i = e[i].nt) &#123;</span><br><span class="line">        <span class="keyword">if</span> (level[e[i].y] == level[k] + <span class="number">1</span> &amp;&amp; e[i].v) &#123; </span><br><span class="line">            <span class="keyword">if</span> (d = max_flow(e[i].y, min(flow - maxflow, e[i].v))) &#123;</span><br><span class="line">                maxflow += d;</span><br><span class="line">                e[i].v -= d;</span><br><span class="line">                e[rev[i]].v += d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!maxflow) level[k] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dinic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (make_level())</span><br><span class="line">        <span class="keyword">while</span> (d = max_flow(<span class="number">1</span>, INF))</span><br><span class="line">            ans += d;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getp</span><span class="params">(<span class="keyword">char</span> *b)</span> </span>&#123;</span><br><span class="line">    p[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(b + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; ++i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; b[j + <span class="number">1</span>] != b[i]) j = p[j];</span><br><span class="line">        <span class="keyword">if</span> (b[j + <span class="number">1</span>] == b[i]) j++;</span><br><span class="line">        p[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span> *a, <span class="keyword">char</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(a + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> r = <span class="built_in">strlen</span>(b + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; b[j + <span class="number">1</span>] != a[i]) j = p[j];</span><br><span class="line">        <span class="keyword">if</span> (b[j + <span class="number">1</span>] == a[i]) ++j;</span><br><span class="line">        <span class="keyword">if</span> (j == r)&#123;</span><br><span class="line">            sum += val[id] * (i - r + <span class="number">1</span>);</span><br><span class="line">            j = p[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_node</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ch = s[k] - <span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">if</span> (!trie[node].lin[ch]) &#123;</span><br><span class="line">        trie[node].lin[ch] = ++len;</span><br><span class="line">        trie[len].end = <span class="number">0</span>;</span><br><span class="line">        trie[len].fail = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k == slen) &#123;</span><br><span class="line">        trie[node].end = <span class="number">1</span>;<span class="comment">//++trie[node].end;</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    add_node(k+<span class="number">1</span>, trie[node].lin[ch]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_fail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    head = tail = <span class="number">0</span>;</span><br><span class="line">    q[tail] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (head &lt;= tail) &#123;</span><br><span class="line">        <span class="keyword">int</span> node = q[head++];</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (trie[node].lin[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> nt = trie[node].lin[i];</span><br><span class="line">                <span class="keyword">if</span> (node) &#123;</span><br><span class="line">                    temp = trie[node].fail;</span><br><span class="line">                    <span class="keyword">while</span> (!trie[temp].lin[i] &amp;&amp; temp)</span><br><span class="line">                        temp = trie[temp].fail;</span><br><span class="line">                    trie[nt].fail = trie[temp].lin[i];</span><br><span class="line">                &#125;</span><br><span class="line">                q[++tail] = nt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> node = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> ch = s[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">while</span> (!trie[node].lin[ch] &amp;&amp; node)</span><br><span class="line">            node = trie[node].fail;</span><br><span class="line">        node = tire[node].lin[ch];</span><br><span class="line">        <span class="keyword">int</span> temp = node;</span><br><span class="line">        <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (trie[temp].end &gt;= <span class="number">-1</span>) &#123;</span><br><span class="line">                ans += trie[temp].end;</span><br><span class="line">                trie[temp].end = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = trie[temp].fail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="后缀数组"><a href="#后缀数组" class="headerlink" title="后缀数组"></a>后缀数组</h3><h4 id="倍增算法"><a href="#倍增算法" class="headerlink" title="倍增算法"></a>倍增算法</h4><p>rank：x的排名</p>
<p>sa：排第x的下标</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">rua</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rank[x] == rank[y] &amp;&amp; rank[x + l] == rank[y + l]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doubling</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m = <span class="number">260</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++cnt[rank[i] = s[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) sa[cnt[rank[i]]--] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i, l = <span class="number">1</span>, k = <span class="number">0</span>; k &lt; n; m = k) &#123;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>,i = n - l + <span class="number">1</span>; i &lt;= n; ++i) p[++k] = i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span>(sa[i] &gt; l) p[++k] = sa[i] - l;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++i) cnt[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) ++cnt[rank[i]];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++i) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (i = n; i; --i) sa[cnt[rank[p[i]]]--] = p[i];</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>, i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">            temp[sa[i]] = rua(sa[i], sa[i<span class="number">-1</span>], l) ? k : ++k;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) rank[i] = temp[i];</span><br><span class="line">        l &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) rank[sa[i]] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>, k; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(k = sa[rank[i] - <span class="number">1</span>])) &#123;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j) --j;</span><br><span class="line">        <span class="keyword">while</span> (s[k + j] == s[i + j]) ++j;</span><br><span class="line">        height[rank[i]] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qaq</span>&#123;</span></span><br><span class="line">    ll maxx, deladd;</span><br><span class="line">    ll delx;</span><br><span class="line">&#125;tree[maxn * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(ll id, ll l, ll r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree[id].delx == <span class="number">1</span> &amp;&amp; tree[id].deladd == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    ll tad = tree[id].deladd;</span><br><span class="line">    ll txx = tree[id].delx;</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    tree[L(id)].deladd = (tree[L(id)].deladd * txx + tad) % mo;</span><br><span class="line">    tree[R(id)].deladd = (tree[R(id)].deladd * txx + tad) % mo;</span><br><span class="line">    tree[L(id)].delx = (tree[L(id)].delx * txx) % mo;</span><br><span class="line">    tree[R(id)].delx = (tree[R(id)].delx * txx) % mo;</span><br><span class="line">    tree[L(id)].maxx = (tree[L(id)].maxx * txx + (mid - l + <span class="number">1</span>) * tad) % mo;</span><br><span class="line">    tree[R(id)].maxx = (tree[R(id)].maxx * txx + (r - mid) * tad) % mo;</span><br><span class="line">    tree[id].deladd = <span class="number">0</span>;</span><br><span class="line">    tree[id].delx = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll l, ll r, ll id, ll v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; y || r &lt; x) <span class="keyword">return</span>;</span><br><span class="line">    tree[id].delx = <span class="number">1</span>;</span><br><span class="line">    tree[id].deladd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">        tree[id].maxx = v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(l, mid, L(id), v);</span><br><span class="line">    build(mid + <span class="number">1</span>, r, R(id), v);</span><br><span class="line">    tree[id].maxx = (tree[L(id)].maxx + tree[R(id)].maxx) % mo;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updatax</span><span class="params">(ll l, ll r, ll id, ll v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; y || r &lt; x) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">        tree[id].deladd = (tree[id].deladd * v) % mo;</span><br><span class="line">        tree[id].delx = (tree[id].delx * v) % mo;</span><br><span class="line">        tree[id].maxx = (tree[id].maxx * v) % mo;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(id, l, r);</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    updatax(l, mid, L(id), v);</span><br><span class="line">    updatax(mid + <span class="number">1</span>, r, R(id), v);</span><br><span class="line">    tree[id].maxx = (tree[L(id)].maxx + tree[R(id)].maxx) % mo;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updataadd</span><span class="params">(ll l, ll r, ll id, ll v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; y || r &lt; x) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">        tree[id].deladd = (tree[id].deladd + v) % mo;</span><br><span class="line">        tree[id].maxx = (tree[id].maxx + (r - l + <span class="number">1</span>) * v) % mo;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(id, l, r);</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    updataadd(l, mid, L(id), v);</span><br><span class="line">    updataadd(mid + <span class="number">1</span>, r, R(id), v);</span><br><span class="line">    tree[id].maxx = (tree[L(id)].maxx + tree[R(id)].maxx) % mo;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">findit</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; y || r &lt; x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">        <span class="keyword">return</span> tree[id].maxx % mo;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(id, l, r);</span><br><span class="line">    ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    ll t1 = findit(l, mid, L(id));</span><br><span class="line">    ll t2 = findit(mid + <span class="number">1</span>, r, R(id));</span><br><span class="line">    <span class="keyword">return</span> (t1 + t2) % mo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h3><h4 id="Splay"><a href="#Splay" class="headerlink" title="Splay"></a>Splay</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">relation</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pos == rc(tree[pos].fa);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    tree[pos].siz = tree[lc(pos)].siz + tree[rc(pos)].siz + tree[pos].wit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    tree[x].son[z] = y;</span><br><span class="line">    tree[y].fa = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f = father(pos);</span><br><span class="line">    <span class="keyword">bool</span> flag = relation(pos);</span><br><span class="line">    ins(father(f), pos, relation(f));</span><br><span class="line">    ins(f, tree[pos].son[flag^<span class="number">1</span>], flag);</span><br><span class="line">    ins(pos, f, flag^<span class="number">1</span>);</span><br><span class="line">    maintain(f);</span><br><span class="line">    maintain(pos);</span><br><span class="line">    <span class="keyword">if</span> (!father(pos)) root = pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> tar = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (tree[pos].fa != tar) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tree[father(pos)].fa != tar) &#123;</span><br><span class="line">            <span class="keyword">if</span> (relation(pos) == relation(father(pos))) rotate(father(pos));</span><br><span class="line">            <span class="keyword">else</span> rotate(pos);</span><br><span class="line">        &#125;</span><br><span class="line">        rotate(pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = root, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pos) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tree[pos].v &gt;= v) pos = lc(pos);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = pos;</span><br><span class="line">            pos = rc(pos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    splay(ans);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">succ</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, pos = root;</span><br><span class="line">    <span class="keyword">while</span> (pos) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tree[pos].v &lt;= v) pos = rc(pos);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = pos;</span><br><span class="line">            pos = lc(pos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    splay(ans);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = root;</span><br><span class="line">    <span class="keyword">while</span> (pos &amp;&amp; tree[pos].v != v) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v &lt; tree[pos].v) pos = lc(pos);</span><br><span class="line">        <span class="keyword">else</span> pos = rc(pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pos) &#123;</span><br><span class="line">        splay(pos);</span><br><span class="line">        <span class="comment">//return root;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = find(v);</span><br><span class="line">    <span class="keyword">if</span> (tree[pos].wit &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        --tree[pos].siz;</span><br><span class="line">        --tree[pos].wit;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> y = succ(v); </span><br><span class="line">    <span class="keyword">int</span> x = pre(v);</span><br><span class="line">    splay(y, x);</span><br><span class="line">    <span class="comment">//lc(y) = 0;</span></span><br><span class="line">    tree[y].son[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    --tree[y].siz;</span><br><span class="line">    --tree[x].siz;</span><br><span class="line">    <span class="comment">//dfs(root);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = root, lt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pos &amp;&amp; tree[pos].v != v) &#123;</span><br><span class="line">        ++tree[pos].siz;</span><br><span class="line">        lt = pos;</span><br><span class="line">        <span class="keyword">if</span> (v &lt; tree[pos].v) pos = lc(pos);</span><br><span class="line">        <span class="keyword">else</span> pos = rc(pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pos) &#123;</span><br><span class="line">        ++tree[pos].siz;</span><br><span class="line">        ++tree[pos].wit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        pos = ++len;</span><br><span class="line">        tree[pos].v = v;</span><br><span class="line">        tree[pos].siz = tree[pos].wit = <span class="number">1</span>;</span><br><span class="line">        lc(pos) = rc(pos) = <span class="number">0</span>;</span><br><span class="line">        father(pos) = lt;</span><br><span class="line">        tree[lt].son[v &gt; tree[lt].v] = pos;</span><br><span class="line">    &#125;</span><br><span class="line">    splay(pos);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rank</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = find(v);</span><br><span class="line">    <span class="keyword">if</span> (!pos) &#123;</span><br><span class="line">        pos = insert(v);</span><br><span class="line">        <span class="keyword">int</span> ans = tree[lc(pos)].siz;</span><br><span class="line">        del(v);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree[lc(pos)].siz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = root;</span><br><span class="line">    <span class="keyword">int</span> sz = tree[lc(pos)].siz;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; sz || k &gt;= sz + tree[pos].wit) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; sz) pos = lc(pos);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            k -= sz + tree[pos].wit;</span><br><span class="line">            pos = rc(pos);</span><br><span class="line">        &#125;</span><br><span class="line">        sz = tree[lc(pos)].siz;</span><br><span class="line">    &#125;</span><br><span class="line">    splay(pos);</span><br><span class="line">    <span class="keyword">return</span> tree[pos].v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">////区间反转，find要加pushdown</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rever</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xx = find(root, x);</span><br><span class="line">    <span class="keyword">int</span> yy = find(root, y + <span class="number">2</span>);</span><br><span class="line">    splay(xx);</span><br><span class="line">    splay(yy, xx);</span><br><span class="line">    tree[lc(yy)].rev ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree[pos].rev) &#123;</span><br><span class="line">        tree[pos].rev = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">std</span>::swap(lc(pos), rc(pos));</span><br><span class="line">        <span class="keyword">if</span> (lc(pos)) tree[lc(pos)].rev ^= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (rc(pos)) tree[rc(pos)].rev ^= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Treap"><a href="#Treap" class="headerlink" title="Treap"></a>Treap</h4><h5 id="不带指针"><a href="#不带指针" class="headerlink" title="不带指针"></a>不带指针</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">treap_node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> fix, val, tim, size, weight, id;</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">&#125;treap[sid + <span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">left_size</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> treap[p].l ? treap[treap[p].l].size : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">right_size</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> treap[p].r ? treap[treap[p].r].size : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash_string</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch[<span class="number">15</span>];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">&#125;hash[sid + <span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bkdr_hash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> seed = <span class="number">131</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= k) &#123;</span><br><span class="line">        temp = temp * seed + str[i];</span><br><span class="line">        ++i;</span><br><span class="line">        temp %= sid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp % sid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = bkdr_hash();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">strlen</span>(hash[temp].ch + <span class="number">1</span>) &amp;&amp; <span class="built_in">strcmp</span>(hash[temp].ch + <span class="number">1</span>, str + <span class="number">1</span>)) &#123;</span><br><span class="line">        temp += step;</span><br><span class="line">        <span class="keyword">if</span> (temp &gt; sid) temp -= sid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">treap_left_rotate</span><span class="params">(<span class="keyword">int</span> &amp;a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = treap[a].r;</span><br><span class="line">    treap[a].r = treap[b].l;</span><br><span class="line">    treap[b].l = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = treap[a].l;</span><br><span class="line">    treap[b].size = left_size(b) + right_size(b) + treap[b].weight;</span><br><span class="line">    treap[a].size = left_size(a) + right_size(a) + treap[a].weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">treap_right_rotate</span><span class="params">(<span class="keyword">int</span> &amp;a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = treap[a].l;</span><br><span class="line">    treap[a].l = treap[b].r;</span><br><span class="line">    treap[b].r = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = treap[a].r;</span><br><span class="line">    treap[b].size = left_size(b) + right_size(b) + treap[b].weight;</span><br><span class="line">    treap[a].size = left_size(a) + right_size(a) + treap[a].weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">treap_insert</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> val, <span class="keyword">int</span> tim, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!p) &#123;</span><br><span class="line">        p = ++tot;</span><br><span class="line">        treap[p].val = val;</span><br><span class="line">        treap[p].fix = rand() * rand() % <span class="number">19260817</span>;</span><br><span class="line">        treap[p].tim = tim;</span><br><span class="line">        treap[p].id = id;</span><br><span class="line">        treap[p].weight = <span class="number">1</span>;</span><br><span class="line">        treap[p].size = <span class="number">1</span>;</span><br><span class="line">        mark[id] = val;</span><br><span class="line">        taim[id] = tim;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ++treap[p].size;</span><br><span class="line">    <span class="keyword">if</span> (val &gt; treap[p].val) &#123;</span><br><span class="line">        treap_insert(treap[p].l, val, tim, id);</span><br><span class="line">        <span class="keyword">if</span> (treap[treap[p].l].fix &lt; treap[p].fix) </span><br><span class="line">            treap_right_rotate(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; treap[p].val) &#123;</span><br><span class="line">        treap_insert(treap[p].r, val, tim, id);</span><br><span class="line">        <span class="keyword">if</span> (treap[treap[p].r].fix &lt; treap[p].fix) </span><br><span class="line">            treap_left_rotate(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tim &lt; treap[p].tim) &#123;</span><br><span class="line">            treap_insert(treap[p].l, val, tim, id);</span><br><span class="line">            <span class="keyword">if</span> (treap[treap[p].l].fix &lt; treap[p].fix)</span><br><span class="line">                treap_right_rotate(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            treap_insert(treap[p].r, val, tim, id);</span><br><span class="line">            <span class="keyword">if</span> (treap[treap[p].r].fix &lt; treap[p].fix)</span><br><span class="line">                treap_left_rotate(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">treap_delete</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (treap[p].id == id) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((!treap[p].r) || (!treap[p].l)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (treap[p].l) p = treap[p].l;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (treap[p].r) p = treap[p].r;</span><br><span class="line">            <span class="keyword">else</span> p = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (treap[treap[p].l].fix &lt; treap[treap[p].r].fix) &#123;</span><br><span class="line">                treap_right_rotate(p);</span><br><span class="line">                treap_delete(treap[p].r, id);</span><br><span class="line">                --treap[p].size;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                treap_left_rotate(p);</span><br><span class="line">                treap_delete(treap[p].l, id);</span><br><span class="line">                --treap[p].size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mark[id] &gt; treap[p].val) &#123;</span><br><span class="line">        treap_delete(treap[p].l, id);</span><br><span class="line">        --treap[p].size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mark[id] &lt; treap[p].val)&#123;</span><br><span class="line">        treap_delete(treap[p].r, id);</span><br><span class="line">        --treap[p].size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (taim[id] &lt; treap[p].tim) &#123;</span><br><span class="line">            treap_delete(treap[p].l, id);</span><br><span class="line">            --treap[p].size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            treap_delete(treap[p].r, id);</span><br><span class="line">            --treap[p].size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">treap_rank</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> id, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (treap[p].id == id) </span><br><span class="line">        <span class="keyword">return</span> left_size(p) + <span class="number">1</span> + cur;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mark[id] &gt; treap[p].val) </span><br><span class="line">        <span class="keyword">return</span> treap_rank(treap[p].l, id, cur);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mark[id] &lt; treap[p].val)</span><br><span class="line">        <span class="keyword">return</span> treap_rank(treap[p].r, id, cur + left_size(p) + treap[p].weight);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (taim[id] &lt; treap[p].tim) </span><br><span class="line">            <span class="keyword">return</span> treap_rank(treap[p].l, id, cur);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> treap_rank(treap[p].r, id, cur + left_size(p) + treap[p].weight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">treap_kth</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; left_size(p) + <span class="number">1</span>) <span class="keyword">return</span> treap_kth(treap[p].l, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; left_size(p) + treap[p].weight) </span><br><span class="line">        <span class="keyword">return</span> treap_kth(treap[p].r, k - (left_size(p) + treap[p].weight));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> treap[p].id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="带指针"><a href="#带指针" class="headerlink" title="带指针"></a>带指针</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">treap</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> fix;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    treap *l, *r;</span><br><span class="line">&#125;;</span><br><span class="line">treap *root = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">left_rotate</span><span class="params">(treap* &amp;a)</span> </span>&#123;</span><br><span class="line">    treap *b = a -&gt; r;</span><br><span class="line">    a -&gt; r = b -&gt; l;</span><br><span class="line">    b -&gt; l = a;</span><br><span class="line">    a = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">right_rotate</span><span class="params">(treap* &amp;a)</span> </span>&#123;</span><br><span class="line">    treap *b = a -&gt; l;</span><br><span class="line">    a -&gt; l = b -&gt; r;</span><br><span class="line">    b -&gt; r = a;</span><br><span class="line">    a = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">treap_insert</span><span class="params">(treap* &amp;p, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        p = <span class="keyword">new</span> treap;</span><br><span class="line">        p -&gt; val = val;</span><br><span class="line">        p -&gt; fix = rand();</span><br><span class="line">        p -&gt; cnt = <span class="number">1</span>;</span><br><span class="line">        p -&gt; l = p -&gt; r = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (val == p -&gt; val) p -&gt; cnt += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; p -&gt; val) &#123;</span><br><span class="line">        treap_insert(p -&gt; l, val);</span><br><span class="line">        <span class="keyword">if</span> (p -&gt; l -&gt; fix &lt; p -&gt; fix)</span><br><span class="line">            right_rotate(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; p -&gt; val) &#123;</span><br><span class="line">        treap_insert(p -&gt; r, val);</span><br><span class="line">        <span class="keyword">if</span> (p -&gt; r -&gt; fix &lt; p -&gt; fix)</span><br><span class="line">            left_rotate(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">treap_max</span><span class="params">(treap *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (p -&gt; r)</span><br><span class="line">        p = p -&gt; r;</span><br><span class="line">    <span class="keyword">return</span> p -&gt; val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">treap_min</span><span class="params">(treap *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (p -&gt; l)</span><br><span class="line">        p = p -&gt; l;</span><br><span class="line">    <span class="keyword">return</span> p -&gt; val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">treap_delete</span><span class="params">(treap *&amp;p, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (val == p -&gt; val) &#123;</span><br><span class="line">        p-&gt;cnt -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!p -&gt; cnt) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!p -&gt; l || !p -&gt; r) &#123;</span><br><span class="line">                treap *t = p;</span><br><span class="line">                <span class="keyword">if</span> (!p -&gt; l) p = p -&gt; r;</span><br><span class="line">                <span class="keyword">else</span> p = p -&gt; l;</span><br><span class="line">                <span class="keyword">delete</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (p -&gt; l -&gt; fix &lt; p -&gt; r -&gt; fix) &#123;</span><br><span class="line">                    right_rotate(p);</span><br><span class="line">                    treap_delete(p -&gt; r, val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    left_rotate(p);</span><br><span class="line">                    treap_delete(p -&gt; l, val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; p -&gt; val) </span><br><span class="line">        treap_delete(p -&gt; l, val);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        treap_delete(p -&gt; r, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="倍增"><a href="#倍增" class="headerlink" title="倍增"></a>倍增</h3><p>RMQ</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">120</span>][<span class="number">10</span>];<span class="comment">//max</span></span><br><span class="line"><span class="keyword">int</span> b[<span class="number">120</span>][<span class="number">10</span>];<span class="comment">//min</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n; ++j)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; ++i) &#123;</span><br><span class="line">    a[i][j] = max(a[i][j - <span class="number">1</span>], a[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">    b[i][j] = min(b[i][j - <span class="number">1</span>], b[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rangemax</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; (k + <span class="number">1</span>)) &lt;= y - x + <span class="number">1</span>) ++k;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, max(a[x][k], a[y - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rangemin</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; (k + <span class="number">1</span>)) &lt;= y - x + <span class="number">1</span>) ++k;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, min(b[x][k], b[y - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fastpower</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) t = t * x % mod;</span><br><span class="line">        x = x * x % mod;</span><br><span class="line">        y = y &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, mid, temp;</span><br><span class="line">    <span class="keyword">if</span> (l + <span class="number">1</span> &lt; r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        work(l, mid - <span class="number">1</span>);</span><br><span class="line">        work(mid, r);</span><br><span class="line">        temp = l;</span><br><span class="line">        <span class="keyword">for</span> (i = l, j = mid; (i &lt;= mid - <span class="number">1</span>) &amp;&amp; (j &lt;= r); ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; a[j]) &#123;</span><br><span class="line">                c[temp++] = a[j++];</span><br><span class="line">                ans += mid - i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> c[temp++] = a[i++];</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (j &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (; j &lt;= r; j++) c[temp++] = a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt;= mid - <span class="number">1</span>; i++) c[temp++] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) a[i] = c[i];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l + <span class="number">1</span> == r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[l] &gt; a[r]) &#123;</span><br><span class="line">                <span class="keyword">int</span> tt = a[r];</span><br><span class="line">                a[r] = a[l];</span><br><span class="line">                a[l] = tt;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>【洛谷p2146】NOI2015软件包管理器</title>
    <url>/2019/03/06/luogu2146/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Linux用户和OSX用户一定对软件包管理器不会陌生。通过软件包管理器，你可以通过一行命令安装某一个软件包，然后软件包管理器会帮助你从软件源下载软件包，同时自动解决所有的依赖（即下载安装这个软件包的安装所依赖的其它软件包），完成所有的配置。Debian/Ubuntu使用的apt-get，Fedora/CentOS使用的yum，以及OSX下可用的homebrew都是优秀的软件包管理器。</p><a id="more"></a>
<p>你决定设计你自己的软件包管理器。不可避免地，你要解决软件包之间的依赖问题。如果软件包A依赖软件包B，那么安装软件包A以前，必须先安装软件包B。同时，如果想要卸载软件包B，则必须卸载软件包A。现在你已经获得了所有的软件包之间的依赖关系。而且，由于你之前的工作，除0号软件包以外，在你的管理器当中的软件包都会依赖一个且仅一个软件包，而0号软件包不依赖任何一个软件包。依赖关系不存在环（若有m(m≥2)个软件包A1,A2,A3,⋯,Am，其中A1依赖A2，A2依赖A3，A3依赖A4，……，A(m-1)依赖Am，而Am依赖A1，则称这m个软件包的依赖关系构成环），当然也不会有一个软件包依赖自己。</p>
<p>现在你要为你的软件包管理器写一个依赖解决程序。根据反馈，用户希望在安装和卸载某个软件包时，快速地知道这个操作实际上会改变多少个软件包的安装状态（即安装操作会安装多少个未安装的软件包，或卸载操作会卸载多少个已安装的软件包），你的任务就是实现这个部分。注意，安装一个已安装的软件包，或卸载一个未安装的软件包，都不会改变任何软件包的安装状态，即在此情况下，改变安装状态的软件包数为0。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>从文件manager.in中读入数据。</p>
<p>输入文件的第1行包含1个整数n，表示软件包的总数。软件包从0开始编号。</p>
<p>随后一行包含n−1个整数，相邻整数之间用单个空格隔开，分别表示1,2,3,⋯,n−2,n−1号软件包依赖的软件包的编号。</p>
<p>接下来一行包含1个整数q，表示询问的总数。之后q行，每行1个询问。询问分为两种：</p>
<p>install x：表示安装软件包x</p>
<p>uninstall x：表示卸载软件包x</p>
<p>你需要维护每个软件包的安装状态，一开始所有的软件包都处于未安装状态。</p>
<p>对于每个操作，你需要输出这步操作会改变多少个软件包的安装状态，随后应用这个操作（即改变你维护的安装状态）。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出到文件manager.out中。</p>
<p>输出文件包括q行。</p>
<p>输出文件的第i行输出1个整数，为第i步操作中改变安装状态的软件包数。</p>
<h3 id="样例一"><a href="#样例一" class="headerlink" title="样例一"></a>样例一</h3><blockquote>
<p>7<br>0 0 0 1 1 5<br>5<br>install 5<br>install 6<br>uninstall 1<br>install 4<br>uninstall 0</p>
<p>3<br>1<br>3<br>2<br>3</p>
</blockquote>
<h3 id="样例二"><a href="#样例二" class="headerlink" title="样例二"></a>样例二</h3><blockquote>
<p>10<br>0 1 2 1 3 0 0 3 2<br>10<br>install 0<br>install 3<br>uninstall 2<br>install 7<br>install 5<br>install 9<br>uninstall 9<br>install 4<br>install 1<br>install 9</p>
<p>1<br>3<br>2<br>1<br>3<br>1<br>1<br>1<br>0<br>1</p>
</blockquote>
<p>值得注意的是标记方法，初始值为-1，这样可以下传0和1</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cl(x, y) memset(x, y, sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(x) (x &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(x) (x &lt;&lt; 1 | 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        k = k * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qaq</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> y, nt;</span><br><span class="line">&#125;e[<span class="number">200100</span>];</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> lin[<span class="number">100100</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qwq</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> laz;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">&#125;tree[<span class="number">400100</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">100100</span>], id[<span class="number">100100</span>], son[<span class="number">100100</span>];</span><br><span class="line"><span class="keyword">int</span> siz[<span class="number">100100</span>], top[<span class="number">100100</span>], dep[<span class="number">100100</span>];</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> ch[<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    siz[x] = <span class="number">1</span>;</span><br><span class="line">    son[x] = n;</span><br><span class="line">    <span class="keyword">for</span> (reg i = lin[x]; i; i = e[i].nt) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = e[i].y;</span><br><span class="line">        <span class="keyword">if</span> (y != fa[x]) &#123;</span><br><span class="line">            fa[y] = x;</span><br><span class="line">            dep[y] = dep[x] + <span class="number">1</span>;</span><br><span class="line">            dfs(y);</span><br><span class="line">            <span class="keyword">if</span> (siz[y] &gt; siz[son[x]]) son[x] = y;</span><br><span class="line">            siz[x] += siz[y];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    id[x] = ++tot;</span><br><span class="line">    top[x] = p;</span><br><span class="line">    <span class="keyword">if</span> (son[x] != n) dfs2(son[x], p);</span><br><span class="line">    <span class="keyword">for</span> (reg i = lin[x]; i; i = e[i].nt) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = e[i].y;</span><br><span class="line">        <span class="keyword">if</span> (y != son[x] &amp;&amp; y != fa[x]) dfs2(y, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    tree[p].l = a;</span><br><span class="line">    tree[p].r = b;</span><br><span class="line">    tree[p].laz = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (a + b) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(ls(p), a, mid);</span><br><span class="line">    build(rs(p), mid + <span class="number">1</span>, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree[p].laz == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tree[p].laz == <span class="number">1</span>) &#123;</span><br><span class="line">        tree[ls(p)].sum = tree[ls(p)].r - tree[ls(p)].l + <span class="number">1</span>;</span><br><span class="line">        tree[rs(p)].sum = tree[rs(p)].r - tree[rs(p)].l + <span class="number">1</span>;</span><br><span class="line">        tree[ls(p)].laz = <span class="number">1</span>;</span><br><span class="line">        tree[rs(p)].laz = <span class="number">1</span>;</span><br><span class="line">        tree[p].laz = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        tree[ls(p)].sum = <span class="number">0</span>;</span><br><span class="line">        tree[rs(p)].sum = <span class="number">0</span>;</span><br><span class="line">        tree[ls(p)].laz = <span class="number">0</span>;</span><br><span class="line">        tree[rs(p)].laz = <span class="number">0</span>;</span><br><span class="line">        tree[p].laz = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = tree[p].l;</span><br><span class="line">    <span class="keyword">int</span> r = tree[p].r;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; a || l &gt; b) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (a &lt;= l &amp;&amp; r &lt;= b) &#123;</span><br><span class="line">        tree[p].laz = v;</span><br><span class="line">        tree[p].sum = v * (r - l + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(p);</span><br><span class="line">    update(ls(p), a, b, v);</span><br><span class="line">    update(rs(p), a, b, v);</span><br><span class="line">    tree[p].sum = tree[ls(p)].sum + tree[rs(p)].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = tree[p].l;</span><br><span class="line">    <span class="keyword">int</span> r = tree[p].r;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; a || l &gt; b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (a &lt;= l &amp;&amp; r &lt;= b) <span class="keyword">return</span> tree[p].sum;</span><br><span class="line">    pushdown(p);</span><br><span class="line">    <span class="keyword">return</span> get_sum(ls(p), a, b) + get_sum(rs(p), a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[x]] &lt; dep[top[y]]) swap(x, y);</span><br><span class="line">        <span class="keyword">int</span> temp = get_sum(<span class="number">1</span>, id[top[x]], id[x]);</span><br><span class="line">        ans += temp;</span><br><span class="line">        update(<span class="number">1</span>, id[top[x]], id[x], <span class="number">1</span>);</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &gt; dep[y]) swap(x, y);</span><br><span class="line">    ans += get_sum(<span class="number">1</span>, id[x], id[y]);</span><br><span class="line">    update(<span class="number">1</span>, id[x], id[y], <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    e[++len].nt = lin[x];</span><br><span class="line">    lin[x] = len;</span><br><span class="line">    e[len].y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cl(fa, <span class="number">-1</span>);</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span> (reg i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = read();</span><br><span class="line">        insert(x, i);</span><br><span class="line">        insert(i, x);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">    dfs2(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    m = read();</span><br><span class="line">    <span class="keyword">for</span> (reg i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, ch);</span><br><span class="line">        <span class="keyword">int</span> x = read();</span><br><span class="line">        <span class="keyword">if</span> (ch[<span class="number">0</span>] == <span class="string">'i'</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> ans = work(x);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dep[x] + <span class="number">1</span> - ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch[<span class="number">0</span>] == <span class="string">'u'</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> ans = get_sum(<span class="number">1</span>, id[x], id[x] + siz[x] - <span class="number">1</span>);</span><br><span class="line">            update(<span class="number">1</span>, id[x], id[x] + siz[x] - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>树链剖分</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>【洛谷p3384】树链剖分</title>
    <url>/2019/03/04/luogu3384/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>如题，已知一棵包含N个结点的树（连通且无环），每个节点上包含一个数值，需要支持以下操作：</p><p>操作1： 格式： 1 x y z 表示将树从x到y结点最短路径上所有节点的值都加上z</p><a id="more"></a>

<p>操作2： 格式： 2 x y 表示求树从x到y结点最短路径上所有节点的值之和</p>
<p>操作3： 格式： 3 x z 表示将以x为根节点的子树内所有节点值都加上z</p>
<p>操作4： 格式： 4 x 表示求以x为根节点的子树内所有节点值之和</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含4个正整数N、M、R、P，分别表示树的结点个数、操作个数、根节点序号和取模数（<strong>即所有的输出结果均对此取模</strong>）。</p>
<p>接下来一行包含N个非负整数，分别依次表示各个节点上初始的数值。</p>
<p>接下来N-1行每行包含两个整数x、y，表示点x和点y之间连有一条边（保证无环且连通）</p>
<p>接下来M行每行包含若干个正整数，每行表示一个操作，格式如下：</p>
<p>操作1： 1 x y z</p>
<p>操作2： 2 x y</p>
<p>操作3： 3 x z</p>
<p>操作4： 4 x</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出包含若干行，分别依次表示每个操作2或操作4所得的结果（<strong>对P取模</strong>）</p>
<h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote>
<p>5 5 2 24<br>7 3 7 8 0<br>1 2<br>1 5<br>3 1<br>4 1<br>3 4 2<br>3 2 2<br>4 5<br>1 5 1 3<br>2 1 3</p>
</blockquote>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote>
<p>2<br>21</p>
</blockquote>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(x) (x&lt;&lt;1|1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qaq</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> y, nt, v;</span><br><span class="line">&#125;e[<span class="number">200100</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qwq</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">int</span> laz;</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">&#125;tree[<span class="number">400100</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lin[<span class="number">100100</span>];</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>, tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, r, mod;</span><br><span class="line"><span class="keyword">int</span> val[<span class="number">100100</span>], siz[<span class="number">100100</span>], son[<span class="number">100100</span>];</span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">100100</span>], top[<span class="number">100100</span>], deep[<span class="number">100100</span>];</span><br><span class="line"><span class="keyword">int</span> id[<span class="number">100100</span>], di[<span class="number">100100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        k = k * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    e[++len].nt = lin[x];</span><br><span class="line">    lin[x] = len;</span><br><span class="line">    e[len].y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    siz[x] = <span class="number">1</span>;</span><br><span class="line">    son[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lin[x]; i; i = e[i].nt) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = e[i].y;</span><br><span class="line">        <span class="keyword">if</span> (y != fa[x]) &#123;</span><br><span class="line">            fa[y] = x;</span><br><span class="line">            deep[y] = deep[x] + <span class="number">1</span>;</span><br><span class="line">            dfs(y);</span><br><span class="line">            <span class="keyword">if</span> (siz[y] &gt; siz[son[x]]) son[x] = y;</span><br><span class="line">            siz[x] += siz[y];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    id[x] = ++tot;</span><br><span class="line">    di[tot] = x;</span><br><span class="line">    top[x] = p;</span><br><span class="line">    <span class="keyword">if</span> (son[x]) dfs2(son[x], p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lin[x]; i; i = e[i].nt) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = e[i].y;</span><br><span class="line">        <span class="keyword">if</span> (y != son[x] &amp;&amp; y != fa[x]) &#123;</span><br><span class="line">            dfs2(y, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    tree[p].l = l;</span><br><span class="line">    tree[p].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tree[p].sum = val[di[l]];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(ls(p), l, mid);</span><br><span class="line">    build(rs(p), mid + <span class="number">1</span>, r);</span><br><span class="line">    tree[p].sum = tree[ls(p)].sum + tree[rs(p)].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree[p].laz) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = tree[p].laz;</span><br><span class="line">        tree[ls(p)].laz += temp;</span><br><span class="line">        tree[rs(p)].laz += temp;</span><br><span class="line">        tree[ls(p)].sum += (tree[ls(p)].r - tree[ls(p)].l + <span class="number">1</span>) * temp;</span><br><span class="line">        tree[rs(p)].sum += (tree[rs(p)].r - tree[rs(p)].l + <span class="number">1</span>) * temp;</span><br><span class="line">        tree[p].laz = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = tree[p].l;</span><br><span class="line">    <span class="keyword">int</span> r = tree[p].r;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; a || l &gt; b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (a &lt;= l &amp;&amp; r &lt;= b) &#123;</span><br><span class="line">        <span class="keyword">return</span> tree[p].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(p);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    ans = get_sum(ls(p), a, b) + get_sum(rs(p), a, b);</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = tree[p].l;</span><br><span class="line">    <span class="keyword">int</span> r = tree[p].r;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; b || r &lt; a) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (a &lt;= l &amp;&amp; r &lt;= b) &#123;</span><br><span class="line">        tree[p].sum += val * (r - l + <span class="number">1</span>);</span><br><span class="line">        tree[p].laz += val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(p);</span><br><span class="line">    update(ls(p), a, b, val);</span><br><span class="line">    update(rs(p), a, b, val);</span><br><span class="line">    tree[p].sum = (tree[ls(p)].sum + tree[rs(p)].sum) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (deep[top[x]] &lt; deep[top[y]]) swap(x, y);</span><br><span class="line">        update(<span class="number">1</span>, id[top[x]], id[x], v);</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (deep[x] &gt; deep[y]) swap(x, y);</span><br><span class="line">    update(<span class="number">1</span>, id[x], id[y], v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (deep[top[x]] &lt; deep[top[y]]) swap(x, y);</span><br><span class="line">        ans += get_sum(<span class="number">1</span>, id[top[x]], id[x]);</span><br><span class="line">        ans %= mod;</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (deep[x] &gt; deep[y]) swap(x, y);</span><br><span class="line">    ans += get_sum(<span class="number">1</span>, id[x], id[y]);</span><br><span class="line">    ans %= mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, x, id[x]);</span><br><span class="line">    <span class="keyword">for</span> (reg i = lin[x]; i; i = e[i].nt) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e[i].y != fa[x]) prt(e[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = read(), m = read(), r = read(), mod = read();</span><br><span class="line">    <span class="keyword">for</span> (reg i = <span class="number">1</span>; i &lt;= n; ++i) val[i] = read();</span><br><span class="line">    <span class="keyword">for</span> (reg i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = read(), y = read();</span><br><span class="line">        insert(x, y);</span><br><span class="line">        insert(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(r);</span><br><span class="line">    dfs2(r, r);</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (reg i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = read();</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = read(), y = read(), v = read();</span><br><span class="line">            work1(x, y, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = read(), y = read();</span><br><span class="line">            work2(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = read(), v = read();</span><br><span class="line">            update(<span class="number">1</span>, id[x], id[x] + siz[x] - <span class="number">1</span>, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = read();</span><br><span class="line">            <span class="keyword">int</span> ans = get_sum(<span class="number">1</span>, id[x], id[x] + siz[x] - <span class="number">1</span>);</span><br><span class="line">            ans %= mod;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>树链剖分</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>【bzoj3223】文艺平衡树</title>
    <url>/2019/01/20/bzoj3223/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote>
<p>您需要写一种数据结构（可参考题目标题），来维护一个有序数列，其中需要提供以下操作：翻转一个区间，例如原有序序列是5 4 3 2 1，翻转区间是2,4的话，结果是5 2 3 4 1</p>
</blockquote><a id="more"></a>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote>
<p>第一行为n,m n表示初始序列有n个数，这个序列依次是(1,2……n-1,n)  m表示翻转操作次数<br>接下来m行每行两个数l,r 数据保证 1&lt;=l&lt;=r&lt;=n </p>
</blockquote>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote>
<p>输出一行n个数字，表示原始序列经过m次变换后的结果</p>
</blockquote>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote>
<p>5 3</p>
<p>1 3  </p>
<p>1 3  </p>
<p>1 4  </p>
</blockquote>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote>
<p>4 3 2 1 5</p>
</blockquote>
<h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>N,M&lt;=100000</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cl(x) memset(x, 0, sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc(x) tree[x].son[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc(x) tree[x].son[1]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fa(x) tree[x].father</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">splay</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> son[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> father;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> siz;</span><br><span class="line">    <span class="keyword">bool</span> rev;</span><br><span class="line">&#125;tree[<span class="number">100100</span>];</span><br><span class="line"><span class="keyword">int</span> root = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        k = k * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cp</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pos == rc(fa(pos));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    tree[pos].siz = tree[lc(pos)].siz + tree[rc(pos)].siz + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">bool</span> z)</span> </span>&#123;</span><br><span class="line">    tree[x].son[z] = y; fa(y) = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree[pos].rev) &#123;</span><br><span class="line">        tree[pos].rev = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">std</span>::swap(lc(pos), rc(pos));</span><br><span class="line">        <span class="keyword">if</span> (lc(pos)) tree[lc(pos)].rev ^= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (rc(pos)) tree[rc(pos)].rev ^= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f = fa(pos);</span><br><span class="line">    <span class="keyword">bool</span> flag = cp(pos);</span><br><span class="line">    ins(fa(f), pos, cp(f));</span><br><span class="line">    ins(f, tree[pos].son[flag^<span class="number">1</span>], flag);</span><br><span class="line">    ins(pos, f, flag^<span class="number">1</span>);</span><br><span class="line">    maintain(f);</span><br><span class="line">    maintain(pos);</span><br><span class="line">    <span class="keyword">if</span> (!fa(pos)) root = pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> tar = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (fa(pos) != tar) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fa(fa(pos)) != tar) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cp(pos) == cp(fa(pos))) rotate(fa(pos));</span><br><span class="line">            <span class="keyword">else</span> rotate(pos);</span><br><span class="line">        &#125;</span><br><span class="line">        rotate(pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    pushdown(pos);</span><br><span class="line">    <span class="keyword">if</span> (tree[lc(pos)].siz + <span class="number">1</span> == v) <span class="keyword">return</span> pos;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tree[lc(pos)].siz &gt;= v) <span class="keyword">return</span> find(lc(pos), v);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> find(rc(pos), v - tree[lc(pos)].siz - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = root;</span><br><span class="line">    <span class="keyword">int</span> lt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pos &amp;&amp; tree[pos].v != v) &#123;</span><br><span class="line">        lt = pos;</span><br><span class="line">        <span class="keyword">if</span> (v &lt; tree[pos].v) pos = lc(pos);</span><br><span class="line">        <span class="keyword">else</span> pos = rc(pos);</span><br><span class="line">    &#125;</span><br><span class="line">    pos = ++len;</span><br><span class="line">    tree[pos].v = v;</span><br><span class="line">    tree[pos].siz = <span class="number">1</span>;</span><br><span class="line">    lc(pos) = rc(pos) = <span class="number">0</span>;</span><br><span class="line">    tree[pos].rev = <span class="number">0</span>;</span><br><span class="line">    fa(pos) = lt;</span><br><span class="line">    tree[lt].son[v &gt; tree[lt].v] = pos;</span><br><span class="line">    splay(pos);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rever</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xx = find(root, x);</span><br><span class="line">    <span class="keyword">int</span> yy = find(root, y + <span class="number">2</span>);</span><br><span class="line">    splay(xx);</span><br><span class="line">    splay(yy, xx);</span><br><span class="line">    tree[lc(yy)].rev ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    pushdown(pos);</span><br><span class="line">    <span class="keyword">if</span> (lc(pos)) dfs(lc(pos));</span><br><span class="line">    <span class="keyword">if</span> (tree[pos].v &gt;= <span class="number">1</span> &amp;&amp; tree[pos].v &lt;= n) <span class="built_in">printf</span>(<span class="string">"%d "</span>, tree[pos].v);</span><br><span class="line">    <span class="keyword">if</span> (rc(pos)) dfs(rc(pos));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    insert(<span class="number">0</span>);</span><br><span class="line">    root = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (reg i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i) insert(i);</span><br><span class="line">    m = read();</span><br><span class="line">    <span class="keyword">for</span> (reg i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = read();</span><br><span class="line">        <span class="keyword">int</span> y = read();</span><br><span class="line">        rever(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>平衡树</category>
        <category>splay</category>
      </categories>
      <tags>
        <tag>splay</tag>
      </tags>
  </entry>
  <entry>
    <title>【bzoj3224】普通平衡树</title>
    <url>/2019/01/15/bzoj3224/</url>
    <content><![CDATA[<h3 id="描述-Description"><a href="#描述-Description" class="headerlink" title="描述 Description"></a>描述 Description</h3><blockquote>
<p>您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作</p>
</blockquote><a id="more"></a>
<ol>
<li>插入x数  </li>
<li>删除x数(若有多个相同的数，因只删除一个)  </li>
<li>查询x数的排名(若有多个相同的数，因输出最小的排名)  </li>
<li>查询排名为x的数  </li>
<li>求x的前驱(前驱定义为小于x，且最大的数)  </li>
<li>求x的后继(后继定义为大于x，且最小的数)  </li>
</ol>
<h3 id="输入格式-Input-Format"><a href="#输入格式-Input-Format" class="headerlink" title="输入格式 Input Format"></a>输入格式 Input Format</h3><blockquote>
<p>第一行为n，表示操作的个数,下面n行每行有两个数opt和x，opt表示操作的序号(1&lt;=opt&lt;=6)</p>
</blockquote>
<h3 id="输出格式-Output-Format"><a href="#输出格式-Output-Format" class="headerlink" title="输出格式 Output Format"></a>输出格式 Output Format</h3><blockquote>
<p>对于操作3,4,5,6每行输出一个数，表示对应答案</p>
</blockquote>
<h3 id="样例输入-Sample-Input"><a href="#样例输入-Sample-Input" class="headerlink" title="样例输入 Sample Input"></a>样例输入 Sample Input</h3><blockquote>
<p>8<br>1 10<br>1 20<br>1 30<br>3 20<br>4 2<br>2 10<br>5 25<br>6 -1</p>
</blockquote>
<h3 id="样例输出-Sample-Output"><a href="#样例输出-Sample-Output" class="headerlink" title="样例输出 Sample Output"></a>样例输出 Sample Output</h3><blockquote>
<p>2</p>
<p>20</p>
<p>20</p>
<p>20</p>
</blockquote>
<h3 id="注释-Hint"><a href="#注释-Hint" class="headerlink" title="注释 Hint"></a>注释 Hint</h3><p>n&lt;=100000 所有数字均在-10^7到10^7内</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cl(x) memset(x, 0, sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc(x) tree[x].son[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc(x) tree[x].son[1]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> father(x) tree[x].fa</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">splay</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> siz, wit;</span><br><span class="line">    <span class="keyword">int</span> fa, son[<span class="number">2</span>];</span><br><span class="line">&#125;tree[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> root = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, pos, tree[pos].v);</span><br><span class="line">        dfs(lc(pos));</span><br><span class="line">        dfs(rc(pos));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        k = k * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">relation</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pos == rc(tree[pos].fa);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    tree[pos].siz = tree[lc(pos)].siz + tree[rc(pos)].siz + tree[pos].wit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    tree[x].son[z] = y;</span><br><span class="line">    tree[y].fa = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f = father(pos);</span><br><span class="line">    <span class="keyword">bool</span> flag = relation(pos);</span><br><span class="line">    ins(father(f), pos, relation(f));</span><br><span class="line">    ins(f, tree[pos].son[flag^<span class="number">1</span>], flag);</span><br><span class="line">    ins(pos, f, flag^<span class="number">1</span>);</span><br><span class="line">    maintain(f);</span><br><span class="line">    maintain(pos);</span><br><span class="line">    <span class="keyword">if</span> (!father(pos)) root = pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> tar = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (tree[pos].fa != tar) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tree[father(pos)].fa != tar) &#123;</span><br><span class="line">            <span class="keyword">if</span> (relation(pos) == relation(father(pos))) rotate(father(pos));</span><br><span class="line">            <span class="keyword">else</span> rotate(pos);</span><br><span class="line">        &#125;</span><br><span class="line">        rotate(pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = root, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pos) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tree[pos].v &gt;= v) pos = lc(pos);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = pos;</span><br><span class="line">            pos = rc(pos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    splay(ans);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">succ</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, pos = root;</span><br><span class="line">    <span class="keyword">while</span> (pos) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tree[pos].v &lt;= v) pos = rc(pos);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = pos;</span><br><span class="line">            pos = lc(pos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    splay(ans);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = root;</span><br><span class="line">    <span class="keyword">while</span> (pos &amp;&amp; tree[pos].v != v) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v &lt; tree[pos].v) pos = lc(pos);</span><br><span class="line">        <span class="keyword">else</span> pos = rc(pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pos) &#123;</span><br><span class="line">        splay(pos);</span><br><span class="line">        <span class="comment">//return root;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = find(v);</span><br><span class="line">    <span class="keyword">if</span> (tree[pos].wit &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        --tree[pos].siz;</span><br><span class="line">        --tree[pos].wit;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> y = succ(v); </span><br><span class="line">    <span class="keyword">int</span> x = pre(v);</span><br><span class="line">    splay(y, x);</span><br><span class="line">    <span class="comment">//lc(y) = 0;</span></span><br><span class="line">    tree[y].son[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    --tree[y].siz;</span><br><span class="line">    --tree[x].siz;</span><br><span class="line">    <span class="comment">//dfs(root);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = root, lt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pos &amp;&amp; tree[pos].v != v) &#123;</span><br><span class="line">        ++tree[pos].siz;</span><br><span class="line">        lt = pos;</span><br><span class="line">        <span class="keyword">if</span> (v &lt; tree[pos].v) pos = lc(pos);</span><br><span class="line">        <span class="keyword">else</span> pos = rc(pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pos) &#123;</span><br><span class="line">        ++tree[pos].siz;</span><br><span class="line">        ++tree[pos].wit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        pos = ++len;</span><br><span class="line">        tree[pos].v = v;</span><br><span class="line">        tree[pos].siz = tree[pos].wit = <span class="number">1</span>;</span><br><span class="line">        lc(pos) = rc(pos) = <span class="number">0</span>;</span><br><span class="line">        father(pos) = lt;</span><br><span class="line">        tree[lt].son[v &gt; tree[lt].v] = pos;</span><br><span class="line">    &#125;</span><br><span class="line">    splay(pos);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rank</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = find(v);</span><br><span class="line">    <span class="keyword">if</span> (!pos) &#123;</span><br><span class="line">        pos = insert(v);</span><br><span class="line">        <span class="keyword">int</span> ans = tree[lc(pos)].siz;</span><br><span class="line">        del(v);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree[lc(pos)].siz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = root;</span><br><span class="line">    <span class="keyword">int</span> sz = tree[lc(pos)].siz;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; sz || k &gt;= sz + tree[pos].wit) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; sz) pos = lc(pos);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            k -= sz + tree[pos].wit;</span><br><span class="line">            pos = rc(pos);</span><br><span class="line">        &#125;</span><br><span class="line">        sz = tree[lc(pos)].siz;</span><br><span class="line">    &#125;</span><br><span class="line">    splay(pos);</span><br><span class="line">    <span class="keyword">return</span> tree[pos].v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) &#123;<span class="built_in">putchar</span>(<span class="string">'0'</span>); <span class="built_in">putchar</span>(<span class="string">'\n'</span>);&#125;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;<span class="built_in">putchar</span>(<span class="string">'-'</span>); x = -x;&#125;</span><br><span class="line">    <span class="keyword">char</span> ch[<span class="number">15</span>];</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;ch[++top] = x % <span class="number">10</span> + <span class="string">'0'</span>; x /= <span class="number">10</span>;&#125;</span><br><span class="line">    <span class="keyword">while</span> (top) <span class="built_in">putchar</span>(ch[top--]);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    insert(<span class="number">0x7fffffff</span>);</span><br><span class="line">    root = <span class="number">1</span>;</span><br><span class="line">    insert(<span class="number">0x80000000</span>);</span><br><span class="line">    <span class="keyword">for</span> (reg i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="comment">//dfs(root);</span></span><br><span class="line">        <span class="keyword">int</span> o = read(), v = read();</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="number">1</span>) insert(v);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (o == <span class="number">2</span>) del(v);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (o == <span class="number">3</span>) put(rank(v));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (o == <span class="number">4</span>) put(kth(v));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (o == <span class="number">5</span>) put(tree[pre(v)].v);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (o == <span class="number">6</span>) put(tree[succ(v)].v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>平衡树</category>
        <category>splay</category>
      </categories>
      <tags>
        <tag>splay</tag>
      </tags>
  </entry>
  <entry>
    <title>【bzoj1503】NOI2004郁闷的出纳员</title>
    <url>/2018/10/13/bzoj1503/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote>
<p>OIER公司是一家大型专业化软件公司，有着数以万计的员工。作为一名出纳员，我的任务之一便是统计每位员工的工资。这本来是一份不错的工作，但是令人郁闷的是，我们的老板反复无常，经常调整员工的工资。如果他心情好，就可能把每位员工的工资加上一个相同的量。反之，如果心情不好，就可能把他们的工资扣除一个相同的量。我真不知道除了调工资他还做什么其它事情。工资的频繁调整很让员工反感，尤其是集体扣除工资的时候，一旦某位员工发现自己的工资已经低于了合同规定的工资下界，他就会立刻气愤地离开公司，并且再也不会回来了。每位员工的工资下界都是统一规定的。每当一个人离开公司，我就要从电脑中把他的工资档案删去，同样，每当公司招聘了一位新员工，我就得为他新建一个工资档案。老板经常到我这边来询问工资情况，他并不问具体某位员工的工资情况，而是问现在工资第k多的员工拿多少工资。每当这时，我就不得不对数万个员工进行一次漫长的排序，然后告诉他答案。好了，现在你已经对我的工作了解不少了。正如你猜的那样，我想请你编一个工资统计程序。怎么样，不是很困难吧？</p>
</blockquote><a id="more"></a>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote>
<p>第一行有两个非负整数n和min。n表示下面有多少条命令，min表示工资下界。</p>
<p>接下来的n行，每行表示一条命令。命令可以是以下四种之一：</p>
<p>I命令 I_k 新建一个工资档案，初始工资为k。</p>
<pre><code>            如果某员工的初始工资低于工资下界，他将立刻离开公司。 
</code></pre><p>A命令 A_k 把每位员工的工资加上k </p>
<p>S命令 S_k 把每位员工的工资扣除k </p>
<p>F命令 F_k 查询第k多的工资 </p>
<p>_（下划线）表示一个空格，I命令、A命令、S命令中的k是一个非负整数，F命令中的k是一个正整数。 在初始时，可以认为公司里一个员工也没有。 I命令的条数不超过100000 A命令和S命令的总条数不超过100 F命令的条数不超过100000 每次工资调整的调整量不超过1000 新员工的工资不超过100000 </p>
</blockquote>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote>
<p>输出行数为F命令的条数加一。</p>
<p> 对于每条F命令，你的程序要输出一行，仅包含一个整数，为当前工资第k多的员工所拿的工资数，如果k大于目前员工的数目，则输出-1。 </p>
<p>输出文件的最后一行包含一个整数，为离开公司的员工的总数。</p>
</blockquote>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote>
<p>9 10<br>I 60<br>I 70<br>S 50<br>F 2<br>I 30<br>S 15<br>A 5<br>F 1<br>F 2</p>
</blockquote>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote>
<p>10</p>
<p>20</p>
<p>-1</p>
<p>2</p>
</blockquote>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>因为是对每个人修改，引入一个delta作为基准值，修改的时候我们只修改delta，delta的初值为0，插入时插入x – delta，A命令delta += k，S命令delta -= k，并且删除所有小于low – delta的点</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> oo 0x7f7f7f7f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg register int</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">treap_Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> size, weight, val, fix;</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">&#125;treap[<span class="number">100100</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> leave = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n, low;</span><br><span class="line"><span class="keyword">int</span> delta = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> root = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cost = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        k = k * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k * f;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lsize</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> treap[p].l ? treap[treap[p].l].size : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rsize</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> treap[p].r ? treap[treap[p].r].size : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">left_rotate</span><span class="params">(<span class="keyword">int</span> &amp;a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = treap[a].r;</span><br><span class="line">    treap[a].r = treap[b].l;</span><br><span class="line">    treap[b].l = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = treap[a].l;</span><br><span class="line">    treap[b].size = lsize(b) + rsize(b) + treap[b].weight;</span><br><span class="line">    treap[a].size = lsize(a) + rsize(a) + treap[a].weight;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">right_rotate</span><span class="params">(<span class="keyword">int</span> &amp;a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = treap[a].l;</span><br><span class="line">    treap[a].l = treap[b].r;</span><br><span class="line">    treap[b].r = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = treap[a].r;</span><br><span class="line">    treap[b].size = lsize(b) + rsize(b) + treap[b].weight;</span><br><span class="line">    treap[a].size = lsize(a) + rsize(a) + treap[a].weight;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">treap_insert</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) &#123;</span><br><span class="line">        p = ++tot;</span><br><span class="line">        treap[p].size = <span class="number">1</span>;</span><br><span class="line">        treap[p].weight = <span class="number">1</span>;</span><br><span class="line">        treap[p].val = val;</span><br><span class="line">        treap[p].fix = rand();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ++treap[p].size;</span><br><span class="line">    <span class="keyword">if</span> (val &gt; treap[p].val) &#123;</span><br><span class="line">        treap_insert(treap[p].l, val);</span><br><span class="line">        <span class="keyword">if</span> (treap[treap[p].l].fix &lt; treap[p].fix)</span><br><span class="line">            right_rotate(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; treap[p].val) &#123;</span><br><span class="line">        treap_insert(treap[p].r, val);</span><br><span class="line">        <span class="keyword">if</span> (treap[treap[p].r].fix &lt; treap[p].fix)</span><br><span class="line">            left_rotate(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ++treap[p].weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">treap_delete</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (treap[p].val &lt; val) &#123;</span><br><span class="line">        temp = treap[treap[p].r].size + treap[p].weight;</span><br><span class="line">        p = treap[p].l;</span><br><span class="line">        <span class="keyword">return</span> temp + treap_delete(p, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        temp = treap_delete(treap[p].r, val);</span><br><span class="line">        treap[p].size -= temp;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_kth</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; lsize(p) + <span class="number">1</span>) <span class="keyword">return</span> find_kth(treap[p].l, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; lsize(p) + treap[p].weight)</span><br><span class="line">        <span class="keyword">return</span> find_kth(treap[p].r, k - (treap[p].weight + lsize(p)));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> treap[p].val;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("a.txt", "r", stdin);</span></span><br><span class="line">    <span class="comment">//freopen("b.txt", "w", stdout);</span></span><br><span class="line">    srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    n = read(), low = read();</span><br><span class="line">    <span class="keyword">for</span> (reg i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">int</span> k = read();</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'I'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k &lt; low) <span class="keyword">continue</span>;</span><br><span class="line">            ++num;</span><br><span class="line">            treap_insert(root, k - delta);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'A'</span>) delta += k;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'S'</span>) &#123;</span><br><span class="line">            delta -= k;</span><br><span class="line">            <span class="keyword">int</span> temp = treap_delete(root, low - delta);</span><br><span class="line">            leave += temp;</span><br><span class="line">            num -= temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (k &gt; num) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = find_kth(root, k);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, temp + delta);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, leave);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>平衡树</category>
        <category>Treap</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>【bzoj1834】ZJOI2010网络扩容</title>
    <url>/2018/10/11/bzoj1834/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote>
<p>给定一张有向图，每条边都有一个容量C和一个扩容费用W。这里扩容费用是指将容量扩大1所需的费用。</p>
<p>求：</p>
<p>1、在不扩容的情况下，1到N的最大流；</p>
<p>2、将1到N的最大流增加K所需的最小扩容费用。</p>
</blockquote><a id="more"></a>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote>
<p>第一行包含三个整数N,M,K，表示有向图的点数、边数以及所需要增加的流量。</p>
<p>接下来的M行每行包含四个整数u,v,C,W，表示一条从u到v，容量为C，扩容费用为W的边。</p>
<p>N&lt;=1000，M&lt;=5000，K&lt;=10</p>
</blockquote>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote>
<p>输出文件一行包含两个整数，分别表示问题1和问题2的答案。</p>
</blockquote>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote>
<p>5  8  2</p>
<p>1  2  5  8</p>
<p>2  5  9  9</p>
<p>5  1  6  2</p>
<p>5  1  1  8</p>
<p>1  2  8  7</p>
<p>2  5  4  9</p>
<p>1  2  1  1</p>
<p>1  4  2  1</p>
</blockquote>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote>
<p>13 19</p>
</blockquote>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>第一问就是最基础的最大流问题，用什么算法都可以。</p>
<p>注意的是要建费用为0的边。</p>
<p>然后对于每条边还要建费用为W，流量为K的边</p>
<p>然后建一个0到1的流量K，费用0的边</p>
<p>从0跑一遍费用流就得到了答案</p>
<p>注意不要把以前的边删掉</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> oo 0x7f7f7f7f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg register int</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_flow</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val, flow, nt, y;</span><br><span class="line">    <span class="keyword">int</span> rev;</span><br><span class="line">&#125;e[<span class="number">101000</span>];</span><br><span class="line"><span class="keyword">int</span> lin[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> st, ed;</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">int</span> level[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> q[<span class="number">10100</span>];</span><br><span class="line"><span class="keyword">int</span> head, tail;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_data</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, c, v;</span><br><span class="line">&#125;aa[<span class="number">5010</span>];</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> edge[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> node[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">1010</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        k = k * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k * f;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> val, <span class="keyword">int</span> flow, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    e[++len].nt = lin[x];</span><br><span class="line">    lin[x] = len;</span><br><span class="line">    e[len].y = y;</span><br><span class="line">    e[len].val = val;</span><br><span class="line">    e[len].flow = flow;</span><br><span class="line">    e[len].rev = len + z;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = read(), m = read(), k = read();</span><br><span class="line">    <span class="keyword">for</span> (reg i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = read(), y = read();</span><br><span class="line">        <span class="keyword">int</span> flow = read(), val = read();</span><br><span class="line">        insert(x, y, <span class="number">0</span>, flow, <span class="number">1</span>);</span><br><span class="line">        insert(y, x, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        aa[i].x = x, aa[i].y = y, aa[i].c = flow, aa[i].v = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">make_level</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(level, <span class="number">-1</span>, <span class="keyword">sizeof</span>(level));</span><br><span class="line">    level[st] = <span class="number">0</span>;</span><br><span class="line">    head = <span class="number">1</span>, tail = <span class="number">0</span>;</span><br><span class="line">    q[++tail] = st;</span><br><span class="line">    <span class="keyword">while</span> (head &lt;= tail) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q[head++];</span><br><span class="line">        <span class="keyword">for</span> (reg i = lin[x]; i; i = e[i].nt) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = e[i].y;</span><br><span class="line">            <span class="keyword">if</span> (e[i].flow &amp;&amp; level[y] == <span class="number">-1</span>) &#123;</span><br><span class="line">                level[y] = level[x] + <span class="number">1</span>;</span><br><span class="line">                q[++tail] = y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level[ed] &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_flow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> flow)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxflow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == ed) <span class="keyword">return</span> flow;</span><br><span class="line">    <span class="keyword">for</span> (reg i = lin[x]; i &amp;&amp; maxflow &lt; flow; i = e[i].nt) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = e[i].y;</span><br><span class="line">        <span class="keyword">if</span> (level[y] == level[x] + <span class="number">1</span> &amp;&amp; e[i].flow) &#123;</span><br><span class="line">            <span class="keyword">if</span> (d = max_flow(y, <span class="built_in">std</span>::min(flow - maxflow, e[i].flow))) &#123;</span><br><span class="line">                maxflow += d;</span><br><span class="line">                e[i].flow -= d;</span><br><span class="line">                e[e[i].rev].flow += d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!maxflow) level[x] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dinic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    st = <span class="number">1</span>, ed = n;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (make_level())</span><br><span class="line">        <span class="keyword">while</span> (d = max_flow(st, oo))</span><br><span class="line">            ans += d;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">re_build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    st = <span class="number">0</span>, ed = n;</span><br><span class="line">    <span class="keyword">for</span> (reg i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = aa[i].x, y = aa[i].y;</span><br><span class="line">        <span class="keyword">int</span> flow = k, val = aa[i].v;</span><br><span class="line">        insert(x, y, val, flow, <span class="number">1</span>);</span><br><span class="line">        insert(y, x, -val, <span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    insert(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, k, <span class="number">1</span>);</span><br><span class="line">    insert(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x7f</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    dis[st] = <span class="number">0</span>;</span><br><span class="line">    vis[st] = <span class="number">1</span>;</span><br><span class="line">    head = <span class="number">1</span>, tail = <span class="number">0</span>;</span><br><span class="line">    q[++tail] = st;</span><br><span class="line">    <span class="keyword">while</span> (head &lt;= tail) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q[head++];</span><br><span class="line">        <span class="keyword">for</span> (reg i = lin[x]; i; i = e[i].nt) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = e[i].y;</span><br><span class="line">            <span class="keyword">if</span> (e[i].flow &amp;&amp; dis[x] + e[i].val &lt; dis[y]) &#123;</span><br><span class="line">                dis[y] = dis[x] + e[i].val;</span><br><span class="line">                node[y] = x;</span><br><span class="line">                edge[y] = i;</span><br><span class="line">                <span class="keyword">if</span> (!vis[y]) &#123;</span><br><span class="line">                    q[++tail] = y;</span><br><span class="line">                    vis[y] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[x] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[ed] != oo;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">agu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = oo;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (reg i = ed; i != st; i = node[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e[edge[i]].flow &lt; flow)</span><br><span class="line">            flow = e[edge[i]].flow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (reg i = ed; i != st; i = node[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> te = edge[i];</span><br><span class="line">        e[te].flow -= flow;</span><br><span class="line">        <span class="keyword">int</span> re = e[te].rev;</span><br><span class="line">        e[re].flow += flow;</span><br><span class="line">        sum += e[te].val * flow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cost_flow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (spfa())</span><br><span class="line">        ans += agu();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    dinic();</span><br><span class="line">    re_build();</span><br><span class="line">    cost_flow();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图论</category>
        <category>网络流</category>
        <category>费用流</category>
      </categories>
      <tags>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>【洛谷p2365】任务安排</title>
    <url>/2017/10/05/luogu2365/</url>
    <content><![CDATA[<h3 id="描述-Description"><a href="#描述-Description" class="headerlink" title="描述 Description"></a>描述 Description</h3><blockquote>
<p>N个任务排成一个序列在一台机器上等待完成（顺序不得改变），这N个任务被分成若干批，每批包含相邻的若干任务。从时刻0开始，这些任务被分批加工，第i个任务单独完成所需的时间是Ti。在每批任务开始前，机器需要启动时间S，而完成这批任务所需的时间是各个任务需要时间的总和（同一批任务将在同一时刻完成）。每个任务的费用是它的完成时刻乘以一个费用系数Fi。请确定一个分组方案，使得总费用最小。<br>例如：S=1；T={1,3,4,2,1}；F={3,2,3,3,4}。如果分组方案是{1,2}、{3}、{4,5}，则完成时间分别为{5,5,10,14,14}，费用C={15,10,30,42,56}，总费用就是153。</p>
</blockquote><a id="more"></a>
<h3 id="输入格式-Input-Format"><a href="#输入格式-Input-Format" class="headerlink" title="输入格式 Input Format"></a>输入格式 Input Format</h3><blockquote>
<p>第一行是N(1&lt;=N&lt;=5000)。<br>第二行是S(0&lt;=S&lt;=50)。<br>下面N行每行有一对数，分别为Ti和Fi，均为不大于100的正整数，表示第i个任务单独完成所需的时间是Ti及其费用系数Fi。</p>
</blockquote>
<h3 id="输出格式-Output-Format"><a href="#输出格式-Output-Format" class="headerlink" title="输出格式 Output Format"></a>输出格式 Output Format</h3><blockquote>
<p>一个数，最小的总费用。</p>
</blockquote>
<h3 id="样例输入-Sample-Input"><a href="#样例输入-Sample-Input" class="headerlink" title="样例输入 Sample Input"></a>样例输入 Sample Input</h3><blockquote>
<p>5<br>1<br>1 3<br>3 2<br>4 3<br>2 3<br>1 4</p>
</blockquote>
<h3 id="样例输出-Sample-Output"><a href="#样例输出-Sample-Output" class="headerlink" title="样例输出 Sample Output"></a>样例输出 Sample Output</h3><blockquote>
<p>153</p>
</blockquote>
<h3 id="题解-Solution"><a href="#题解-Solution" class="headerlink" title="题解 Solution"></a>题解 Solution</h3><p>我们用$f[i]$表示从$N$到$i$的最小花费，$F[i],T[i]$是从$N$到$i$的前缀和【$F[i]=F[i+1]+a[i]$】。</p>
<p>得到方程：$f[i]=min{f[j]+(T[i]−T[j]+S)∗F[i]}(i&lt;j&lt;n)$</p>
<p>这样我们可以变形得到：$f[i]=min{f[j]−T[j]∗F[i]}+(T[i]+S)∗F[i]$</p>
<p>对于一个状态$i$我们设$V[j]=f[j]−T[j]∗F[i]$。对于决策$x,y(i&lt;x&lt;y≤n)$，如果$x$比$y$优，即$V(x)&lt;V(y)$，那么$f[x]−T[x]∗F[i]&lt;f[y]−T[y]∗F[i]$</p>
<p>通过变形，我们最终得</p>
<p>$\frac{f[x]−f[y]}{T[x]−T[y]}&lt;F[i]$</p>
<p>我们以$f$为纵坐标，$T$为横坐标，这个就是一个斜率式了。$F[i]$是$i$递减的前缀和，那么$F[i]$随着状态推移会一直增大。那么，如果$x$只要一次比$y$优，以后$x$永远比$y$优。</p>
<p>我们考虑$x,y,z(i&lt;x&lt;y&lt;z≤n)$三个决策，$x$比$y$优即$\frac{f[x]-f[y]}{T[x]-T[y]}&lt;F[i]$,$y$比$z$优$\frac{f[y]-f[z]}{T[y]-T[z]}&lt;F[i]$</p>
<p>因此，当$\frac{f[x]-f[y]}{T[x]-T[y]}&lt;\frac{f[y]-f[z]}{T[y]-T[z]}$时，我们就不需要y了。这也是我们在决策队尾去掉不优于i的判断条件。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t[<span class="number">5010</span>];</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">5010</span>];</span><br><span class="line"><span class="keyword">int</span> sumt[<span class="number">5010</span>];</span><br><span class="line"><span class="keyword">int</span> sumv[<span class="number">5010</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">5010</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> s;</span><br><span class="line"><span class="keyword">int</span> q[<span class="number">5100</span>];</span><br><span class="line"><span class="keyword">int</span> head=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> tail=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_k</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span> * (f[x] - f[y])) / (<span class="number">1.0</span> * (sumt[x] - sumt[y]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    q[++tail] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (head &lt; tail </span><br><span class="line">                &amp;&amp; get_k(q[head + <span class="number">1</span>], q[head]) &lt; sumv[i]) </span><br><span class="line">            ++head;</span><br><span class="line">        <span class="keyword">int</span> j = q[head];</span><br><span class="line">        f[i] = f[j] - sumt[j] * sumv[i] + (sumt[i] + s) * sumv[i];</span><br><span class="line">        <span class="keyword">while</span> (head &lt; tail </span><br><span class="line">                &amp;&amp; get_k(i, q[tail]) &lt; get_k(q[tail], q[tail - <span class="number">1</span>])) </span><br><span class="line">            --tail;</span><br><span class="line">        q[++tail] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;t[i], &amp;v[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        sumt[i] = sumt[i + <span class="number">1</span>] + t[i];</span><br><span class="line">        sumv[i] = sumv[i + <span class="number">1</span>] + v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    solution();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>动态规划</category>
        <category>斜率优化</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>【bzoj2424】HAOI2010订货</title>
    <url>/2017/09/29/bzoj2424/</url>
    <content><![CDATA[<h3 id="描述-Description"><a href="#描述-Description" class="headerlink" title="描述 Description"></a>描述 Description</h3><blockquote>
<p>某公司估计市场在第i个月对某产品的需求量为Ui，已知在第i月该产品的订货单价为di，上个月月底未销完的单位产品要付存贮费用m，假定第一月月初的库存量为零，第n月月底的库存量也为零，问如何安排这n个月订购计划，才能使成本最低？每月月初订购，订购后产品立即到货，进库并供应市场，于当月被售掉则不必付存贮费。假设仓库容量为S。</p>
</blockquote><a id="more"></a>
<h3 id="输入格式-Input-Format"><a href="#输入格式-Input-Format" class="headerlink" title="输入格式 Input Format"></a>输入格式 Input Format</h3><blockquote>
<p>第1行：n,m,S (0&lt;=n&lt;=50,0&lt;=m&lt;=10,0&lt;=S&lt;=10000)</p>
<p>第2行：U1,U2,…,Ui,…,Un (0&lt;=Ui&lt;=10000)</p>
<p>第3行：d1,d2,…,di,…,dn (0&lt;=di&lt;=100)</p>
</blockquote>
<h3 id="输出格式-Output-Format"><a href="#输出格式-Output-Format" class="headerlink" title="输出格式 Output Format"></a>输出格式 Output Format</h3><blockquote>
<p>只有1行，一个整数，代表最低成本</p>
</blockquote>
<h3 id="样例输入-Sample-Input"><a href="#样例输入-Sample-Input" class="headerlink" title="样例输入 Sample Input"></a>样例输入 Sample Input</h3><blockquote>
<p>3  1  1000</p>
<p>2  4  8</p>
<p>1  2  4</p>
</blockquote>
<h3 id="样例输出-Sample-Output"><a href="#样例输出-Sample-Output" class="headerlink" title="样例输出 Sample Output"></a>样例输出 Sample Output</h3><blockquote>
<p>34</p>
</blockquote>
<h3 id="题解-Solution"><a href="#题解-Solution" class="headerlink" title="题解 Solution"></a>题解 Solution</h3><p>用$f[i][j]$表示在第$i$个月存货量为$j$的最小花费，得到</p>
<p>$f[i][j]=min{f[i−1][k]+(u[i]+j−k)∗d[i]+m∗k}(0≤j≤s,k≤u[i]+j)$</p>
<p>变形后：$f[i][j]=min{f[i−1][k]+(m−d[i])∗k}+(u[i]+j)∗d[i]$</p>
<p>那么对于阶段$i$状态$j$，考虑$i-1$的决策$x$ , $y$ , $x&lt;y$，如果$x$更优，则有</p>
<p>$f[i−1][x]+(m−d[i])∗x≤f[i−1][y]+(m−d[i])∗y$</p>
<p>对于每个i我们维护一个队列q，并且从S到0枚举j，从上一阶段队头取最优值，并与队尾比较即可。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> u[<span class="number">60</span>];</span><br><span class="line"><span class="keyword">int</span> lmt;</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">60</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> q[<span class="number">60</span>][<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">60</span>];</span><br><span class="line"><span class="keyword">int</span> tail[<span class="number">60</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">60</span>][<span class="number">10010</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        head[i] = <span class="number">1</span>, tail[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = lmt; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (head[i - <span class="number">1</span>] &lt; tail[i - <span class="number">1</span>] &amp;&amp; q[i - <span class="number">1</span>][head[i - <span class="number">1</span>]] &gt; u[i] + j)</span><br><span class="line">                ++head[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">int</span> k = q[i - <span class="number">1</span>][head[i - <span class="number">1</span>]];</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][k] + (m - d[i]) * k + (u[i] + j) * d[i];</span><br><span class="line">            <span class="keyword">while</span> (f[i][j] + (m - d[i + <span class="number">1</span>]) * j</span><br><span class="line">                    &lt;= f[i][q[i][tail[i]]] + (m - d[i + <span class="number">1</span>]) * q[i][tail[i]] </span><br><span class="line">                    &amp;&amp; head[i] &lt;= tail[i]) --tail[i];</span><br><span class="line">            q[i][++tail[i]] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[n][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; lmt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;u[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;d[i]);</span><br><span class="line">    solution();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>动态规划</category>
        <category>四边形不等式</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>【jzyz-p1326】超级教主</title>
    <url>/2017/09/25/jzyzj1326/</url>
    <content><![CDATA[<h3 id="描述-Description"><a href="#描述-Description" class="headerlink" title="描述 Description"></a>描述 Description</h3><blockquote>
<p>LHX教主很能跳，因为Orz他的人太多了。教主跳需要消耗能量，每跳1米就会消耗1点能量，如果教主有很多能量就能跳很高。<br>教主为了收集能量，来到了一个神秘的地方，这个地方凡人是进不来的。在这里，教主的正上方每100米处就有一个能量球（也就是这些能量球位于海拔100，200，300……米处），每个能量球所能提供的能量是不同的，一共有N个能量球（也就是最后一个能量球在N×100米处）。教主为了想收集能量，想跳着吃完所有的能量球。教主可以自由控制他每次跳的高度，接着他跳起把这个高度以下的能量球都吃了，他便能获得能量球内的能量，接着吃到的能量球消失。教主不会轻功，教主不会二段跳，所以教主不能因新吃到的能量而变化此次跳跃的高度。并且教主还是生活在地球上的，所以教主每次跳完都会掉下来。<br>问教主若要吃完所有的能量球，最多还能保留多少能量。</p>
</blockquote><a id="more"></a>
<h3 id="输入格式-Input-Format"><a href="#输入格式-Input-Format" class="headerlink" title="输入格式 Input Format"></a>输入格式 Input Format</h3><blockquote>
<p>第1行包含两个正整数N，M，表示了能量球的个数和LHX教主的初始能量。<br>第2行包含N个非负整数，从左到右第I个数字依次从下向上描述了位于I×100米位置能量球包含的能量，整数之间用空格隔开。  </p>
</blockquote>
<h3 id="输出格式-Output-Format"><a href="#输出格式-Output-Format" class="headerlink" title="输出格式 Output Format"></a>输出格式 Output Format</h3><blockquote>
<p>仅包括一个非负整数，为教主吃完所有能量球后最多保留的能量。</p>
</blockquote>
<h3 id="样例输入-Sample-Input"><a href="#样例输入-Sample-Input" class="headerlink" title="样例输入 Sample Input"></a>样例输入 Sample Input</h3><blockquote>
<p>3 200<br>200 200 200</p>
</blockquote>
<h3 id="样例输出-Sample-Output"><a href="#样例输出-Sample-Output" class="headerlink" title="样例输出 Sample Output"></a>样例输出 Sample Output</h3><blockquote>
<p>400</p>
</blockquote>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于100%的数据，有$N&lt;=2000000$</p>
<h3 id="题解-Solution"><a href="#题解-Solution" class="headerlink" title="题解 Solution"></a>题解 Solution</h3><p>一道DP单调性优化题，我们用f[i]表示吃到第i个能量球之后能够保留的最大能量，sum数组表示能量球的前缀和，可以得到方程：</p>
<p>$f[i]=max{f[j]+sum[i]−sum[j]−100∗i}(f[j]≥100∗i)$</p>
<p>因为$i$是与$j$无关的，所以我们可以变形为：</p>
<p>$f[i]=max{f[j]−sum[j]}+sum[i]−100∗i(f[j]≥100∗i)$</p>
<p>对于决策x和y，如果x&lt;y，满足：$f[y]−f[x]≥sum[y]–sum[x]$那么我们只需要决策y，因为y更优</p>
<p>我们使用队列q储存决策的下标j，while判断队尾决策是否比i优，不优则出队，然后i入队。在取队头元素时须判断条件$f[j]≥100∗i$不满足就出队</p>
<p>每个元素只会出队/入队一次，所以复杂度是O(n)的。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2000100</span>];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">2000100</span>];</span><br><span class="line">ll sum[<span class="number">2000100</span>];</span><br><span class="line"><span class="keyword">int</span> q[<span class="number">2000100</span>];</span><br><span class="line"><span class="keyword">int</span> head = <span class="number">0</span>, tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'-'</span>) y = <span class="number">-1</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f[<span class="number">0</span>] = m;</span><br><span class="line">    q[++tail] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (head &lt; tail) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[q[head]] &gt;= <span class="number">100</span>*i) <span class="keyword">break</span>;</span><br><span class="line">            head++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j = q[head];</span><br><span class="line">        f[i] = f[j] - sum[j] + sum[i] - <span class="number">100</span> * i;</span><br><span class="line">        <span class="keyword">while</span> (f[i] - f[q[tail]] &gt;= sum[i] - sum[q[tail]]) --tail;</span><br><span class="line">        q[++tail] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f[n]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    m = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        a[i] = read();</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    solution();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>动态规划</category>
        <category>四边形不等式</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>单调性优化</tag>
      </tags>
  </entry>
  <entry>
    <title>【bzoj1055】HAOI2008玩具取名</title>
    <url>/2017/09/18/bzoj1055/</url>
    <content><![CDATA[<h3 id="描述-Description"><a href="#描述-Description" class="headerlink" title="描述 Description"></a>描述 Description</h3><blockquote>
<p>某人有一套玩具，并想法给玩具命名。首先他选择WING四个字母中的任意一个字母作为玩具的基本名字。然后他会根据自己的喜好，将名字中任意一个字母用“WING”中任意两个字母代替，使得自己的名字能够扩充得很长。现在，他想请你猜猜某一个很长的名字，最初可能是由哪几个字母变形过来的。</p>
</blockquote><a id="more"></a>
<h3 id="输入格式-Input-Format"><a href="#输入格式-Input-Format" class="headerlink" title="输入格式 Input Format"></a>输入格式 Input Format</h3><blockquote>
<p>第一行四个整数W、I、N、G。表示每一个字母能由几种两个字母所替代。</p>
<p>接下来W行，每行两个字母,表示W可以用这两个字母替代。</p>
<p>接下来I行，每行两个字母,表示I可以用这两个字母替代。</p>
<p>接下来N行，每行两个字母,表示N可以用这两个字母替代。</p>
<p>接下来G行，每行两个字母,表示G可以用这两个字母替代。</p>
<p>最后一行一个长度不超过Len的字符串。表示这个玩具的名字</p>
</blockquote>
<h3 id="输出格式-Output-Format"><a href="#输出格式-Output-Format" class="headerlink" title="输出格式 Output Format"></a>输出格式 Output Format</h3><blockquote>
<p>一行字符串，该名字可能由哪些字母变形而得到。（按照WING的顺序输出）<br>如果给的名字不能由任何一个字母变形而得到则输出“The name is wrong!”</p>
</blockquote>
<h3 id="样例输入-Sample-Input"><a href="#样例输入-Sample-Input" class="headerlink" title="样例输入 Sample Input"></a>样例输入 Sample Input</h3><blockquote>
<p>1  1  1  1</p>
<p>II</p>
<p>WW</p>
<p>WW</p>
<p>IG</p>
<p>IIII</p>
</blockquote>
<h3 id="样例输出-Sample-Output"><a href="#样例输出-Sample-Output" class="headerlink" title="样例输出 Sample Output"></a>样例输出 Sample Output</h3><blockquote>
<p>IN</p>
</blockquote>
<h3 id="题解-Solution"><a href="#题解-Solution" class="headerlink" title="题解 Solution"></a>题解 Solution</h3><p>一道区间DP，bool记录ab可以表示成c，然后f[i][k][a] &amp;&amp;f[k+1][j][b]可以转移成f[i][j][c]。</p>
<p>以下是代码：</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> w,i,n,g;</span><br><span class="line"><span class="keyword">bool</span> a[<span class="number">5</span>][<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> mp[<span class="number">210</span>];</span><br><span class="line"><span class="keyword">bool</span> f[<span class="number">210</span>][<span class="number">210</span>][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">210</span>];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;len;j++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">4</span>;k++)</span><br><span class="line">            <span class="keyword">if</span>(a[b[j]][b[j+<span class="number">1</span>]][k]) &#123;</span><br><span class="line">                f[j][j+<span class="number">1</span>][k]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">3</span>;p&lt;=len;p++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=len;x++) &#123;</span><br><span class="line">            <span class="keyword">int</span> y=x+p<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(y&gt;len) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=x;k&lt;y;k++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=<span class="number">4</span>;t++) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> o=<span class="number">1</span>;o&lt;=<span class="number">4</span>;o++) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(f[x][k][t]&amp;&amp;f[k+<span class="number">1</span>][y][o]&amp;&amp;a[t][o][<span class="number">1</span>]) f[x][y][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span>(f[x][k][t]&amp;&amp;f[k+<span class="number">1</span>][y][o]&amp;&amp;a[t][o][<span class="number">2</span>]) f[x][y][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span>(f[x][k][t]&amp;&amp;f[k+<span class="number">1</span>][y][o]&amp;&amp;a[t][o][<span class="number">3</span>]) f[x][y][<span class="number">3</span>]=<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span>(f[x][k][t]&amp;&amp;f[k+<span class="number">1</span>][y][o]&amp;&amp;a[t][o][<span class="number">4</span>]) f[x][y][<span class="number">4</span>]=<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> o=<span class="number">1</span>;o&lt;=<span class="number">4</span>;o++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(f[<span class="number">1</span>][len][o]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(o==<span class="number">1</span>) <span class="built_in">putchar</span>(<span class="string">'W'</span>);</span><br><span class="line">            <span class="keyword">if</span>(o==<span class="number">2</span>) <span class="built_in">putchar</span>(<span class="string">'I'</span>);</span><br><span class="line">            <span class="keyword">if</span>(o==<span class="number">3</span>) <span class="built_in">putchar</span>(<span class="string">'N'</span>);</span><br><span class="line">            <span class="keyword">if</span>(o==<span class="number">4</span>) <span class="built_in">putchar</span>(<span class="string">'G'</span>);</span><br><span class="line">            flag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"The name is wrong!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;w&gt;&gt;i&gt;&gt;n&gt;&gt;g;</span><br><span class="line">    mp[<span class="string">'W'</span>]=<span class="number">1</span>;</span><br><span class="line">    mp[<span class="string">'I'</span>]=<span class="number">2</span>;</span><br><span class="line">    mp[<span class="string">'N'</span>]=<span class="number">3</span>;</span><br><span class="line">    mp[<span class="string">'G'</span>]=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">char</span> temp[<span class="number">210</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=w;j++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,temp);</span><br><span class="line">        a[mp[temp[<span class="number">0</span>]]][mp[temp[<span class="number">1</span>]]][mp[<span class="string">'W'</span>]]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,temp);</span><br><span class="line">        a[mp[temp[<span class="number">0</span>]]][mp[temp[<span class="number">1</span>]]][mp[<span class="string">'I'</span>]]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,temp);</span><br><span class="line">        a[mp[temp[<span class="number">0</span>]]][mp[temp[<span class="number">1</span>]]][mp[<span class="string">'N'</span>]]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=g;j++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,temp);</span><br><span class="line">        a[mp[temp[<span class="number">0</span>]]][mp[temp[<span class="number">1</span>]]][mp[<span class="string">'G'</span>]]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,temp);</span><br><span class="line">    len=<span class="built_in">strlen</span>(temp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;j++) &#123;</span><br><span class="line">        b[j+<span class="number">1</span>]=mp[temp[j]];</span><br><span class="line">        f[j+<span class="number">1</span>][j+<span class="number">1</span>][mp[temp[j]]]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    solution();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>动态规划</category>
        <category>区间DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>【poj1149】pigs</title>
    <url>/2017/05/23/poj1149/</url>
    <content><![CDATA[<h3 id="描述-Description"><a href="#描述-Description" class="headerlink" title="描述 Description"></a>描述 Description</h3><blockquote>
<p>尼克在一家养猪场工作，这家养猪场共有M间锁起来的猪舍，由于猪舍的钥匙都给了客户，所以尼克没有办法打开这些猪舍，客户们从早上开始一个接一个来购买生猪，他们到达后首先用手中的钥匙打开他所能打开的全部猪舍，然后从中选取他要买的生猪，尼克可以在此期间将打开的猪舍中的猪调整到其它开着的猪舍中，每个猪舍能存放的猪的数量是没有任何限制的。买完猪后客户会将他打开的猪舍关上。<br>好在尼克事先知道每位客户手中有哪些钥匙，要买多少猪，以及客户到来的先后次序。请你写一个程序，帮助尼克求出最多能卖出多少头生猪。</p>
</blockquote><a id="more"></a>
<h3 id="输入格式-Input-Format"><a href="#输入格式-Input-Format" class="headerlink" title="输入格式 Input Format"></a>输入格式 Input Format</h3><blockquote>
<p>输入文件的第一行包含两个整数M和N，1≤M≤1000，1≤N≤100，M为猪舍的数量，N为客户人数，猪舍的编号为1到M，客户的编号为1到N。<br>输入文件第二行包含M个空格隔开的整数，依次表示每个猪舍中的生猪数量，每个整数大于等于0，且小于等于1000。<br>接下来的N行每行表示一位客户的购买信息，第i个客户的购买信息位于第i+2行，<br>其格式如下：<br>A K1 K2……KA B<br>它表示该客户共有A把钥匙，钥匙编号依次为K1 K2……KA，且K1&lt;K2&lt;……&lt;KA，B为该客户要买的生猪的头数。</p>
</blockquote>
<h3 id="输出格式-Output-Format"><a href="#输出格式-Output-Format" class="headerlink" title="输出格式 Output Format"></a>输出格式 Output Format</h3><blockquote>
<p>输出文件仅有一行包含一个整数，表示尼克最多能卖出的生猪的头数。</p>
</blockquote>
<h3 id="样例输入-Sample-Input"><a href="#样例输入-Sample-Input" class="headerlink" title="样例输入 Sample Input"></a>样例输入 Sample Input</h3><blockquote>
<p>3 3<br>3 1 10<br>2 1 2 2<br>2 1 3 3<br>1 2 6</p>
</blockquote>
<h3 id="样例输出-Sample-Output"><a href="#样例输出-Sample-Output" class="headerlink" title="样例输出 Sample Output"></a>样例输出 Sample Output</h3><blockquote>
<p>7</p>
</blockquote>
<h3 id="题解-Solution"><a href="#题解-Solution" class="headerlink" title="题解 Solution"></a>题解 Solution</h3><p>众所周知网络流难在建图。这道题我刚开始以为是源点连人【权值为需求数】，人连房间【权值为需求数】，房间汇点【是猪的个数】。然而建完图连手推样例都不行，GG。</p>
<p>顺手翻了翻hzwer.com，然后就找到了，发现一个神犇的建图方法：</p>
<ol>
<li><p>每个顾客向汇点连接他的需求数</p>
</li>
<li><p>对于每个猪圈，源点向第一个打开他的顾客连一条权值为猪数量的边</p>
</li>
<li><p>每个顾客向下一个顾客连接一个权值为正无穷的边</p>
</li>
</ol>
<p>对于样例，我们可以建图：</p>
<p>以顾客为点，如图所示</p>
<p><img src="http://images2015.cnblogs.com/blog/1027409/201705/1027409-20170523153329163-1563031939.png" alt="Sample"></p>
<p>【其中的4是猪圈1+2的和，因为他开了两个】最大流为7，符合样例</p>
<p>为什么这样建图？看题中所给的条件：每个顾客打开门后，尼克可以把猪迁移到开的房间。那么显然一个顾客对后面的顾客有影响。那么进入每个顾客的流量显然是这个顾客第一个打开的所有猪舍的和，这样向下一个顾客流，就相当于把猪的位置调换了。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2100000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::min;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> q[<span class="number">2100</span>];</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> s,t;</span><br><span class="line"><span class="keyword">int</span> level[<span class="number">2100</span>];</span><br><span class="line"><span class="keyword">int</span> rev[<span class="number">50010</span>];</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">2100</span>];</span><br><span class="line"><span class="keyword">int</span> lin[<span class="number">2100</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2100</span>];</span><br><span class="line"><span class="keyword">int</span> ha=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qaq</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> nt,y,v;</span><br><span class="line">&#125;e[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">15</span>],*fs,*ft;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">getc</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> (fs==ft &amp;&amp; (ft= (fs=buf) + fread(buf,<span class="number">1</span>,<span class="number">1</span>&lt;&lt;<span class="number">15</span>,<span class="built_in">stdin</span>) , fs==ft) )?<span class="number">0</span>:*fs++;  &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch=getc();<span class="keyword">int</span> k=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;    <span class="keyword">if</span>(ch==<span class="string">'-'</span>)    f=<span class="number">-1</span>;     ch=getc();    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))  &#123; k=(k&lt;&lt;<span class="number">3</span>)+(k&lt;&lt;<span class="number">1</span>)+ch-<span class="string">'0'</span>;    ch=getc();    &#125;</span><br><span class="line">    <span class="keyword">return</span> k*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++len].nt=lin[x]; lin[x]=len; e[len].v=v; e[len].y=y; rev[len]=len+<span class="number">1</span>;</span><br><span class="line">    e[++len].nt=lin[y]; lin[y]=len; e[len].v=<span class="number">0</span>; e[len].y=x; rev[len]=len<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">make_level</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> head=<span class="number">0</span>,tail=<span class="number">1</span>;</span><br><span class="line">    q[<span class="number">1</span>]=s;</span><br><span class="line">    <span class="built_in">memset</span>(level,<span class="number">-1</span>,<span class="keyword">sizeof</span>(level));</span><br><span class="line">    level[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(head&lt;tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x=q[++head];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=lin[x];i;i=e[i].nt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(e[i].v &amp;&amp; level[e[i].y]==<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                level[e[i].y]=level[x]+<span class="number">1</span>;</span><br><span class="line">                q[++tail]=e[i].y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level[t]&gt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_flow</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==t) <span class="keyword">return</span> flow;</span><br><span class="line">    <span class="keyword">int</span> maxflow=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=lin[k];i &amp;&amp; maxflow&lt;flow;i=e[i].nt)</span><br><span class="line">        <span class="keyword">if</span>(e[i].v &amp;&amp; level[e[i].y]==level[k]+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span>(v=max_flow(e[i].y,min(e[i].v,flow-maxflow)))</span><br><span class="line">                maxflow+=v , e[i].v-=v , e[rev[i]].v+=v;</span><br><span class="line">    <span class="keyword">if</span>(!maxflow) level[k]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">while</span>(make_level())</span><br><span class="line">        <span class="keyword">while</span>(v=max_flow(s,INF))</span><br><span class="line">            ans+=v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("a.txt","r",stdin);</span></span><br><span class="line">    m=read();n=read();<span class="comment">//m is pig</span></span><br><span class="line">    <span class="comment">//cout&lt;&lt;n&lt;&lt;' '&lt;&lt;m&lt;&lt;endl;</span></span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    s=<span class="number">0</span>;</span><br><span class="line">    t=n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) a[i]=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> key=read();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=key;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> val=read();</span><br><span class="line">            <span class="keyword">if</span>(!vis[val]) insert(s,i,a[val]);</span><br><span class="line">            <span class="keyword">else</span> insert(vis[val],i,INF);</span><br><span class="line">            vis[val]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        key=read();</span><br><span class="line">        insert(i,t,key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dinic();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图论</category>
        <category>网络流</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>【bzoj1562】NOI2009变换序列</title>
    <url>/2017/04/13/bzoj1562/</url>
    <content><![CDATA[<h3 id="【问题描述】"><a href="#【问题描述】" class="headerlink" title="【问题描述】"></a>【问题描述】</h3><blockquote>
<p>对于<em>N</em>个整数0,1,……,N-1，一个变换序列T可以将i变成Ti，其中 $Ti∈{0,1,…,N-1} $定义x和y之间的距离$D(x,y=min{|x-y|,N-|x-y|})$。给定每个i和Ti之间的距离D(i,Ti)，你需要求出一个满足要求的变换序列<em>T</em>。如果有多个满足条件的序列，输出其中字典序最小的一个。</p>
</blockquote><a id="more"></a>
<p><strong>说明</strong>：对于两个变换序列<em>S</em> 和<em>T</em>，如果存在 <em>p</em> &lt; <em>N</em>，满足对于 <em>i</em> = 0,1,…… <em>p</em> - 1， $S_i$ = <em>$T_i$</em>且 <em>$S_p$</em> &lt; <em>$T_p$</em>，我们称 <em>S</em> 比 <em>T</em> 字典序小。</p>
<h3 id="【输入文件】"><a href="#【输入文件】" class="headerlink" title="【输入文件】"></a><strong>【输入文件】</strong></h3><blockquote>
<p>输入文件transform.in的第一行包含一个整数<em>N</em>，表示序列的长度。接下来的一行包含<em>N</em>个整数<em>Di</em>，其中 <em>Di</em> 表示 <em>i</em> 和 <em>Ti</em> 之间的距离。</p>
</blockquote>
<h3 id="【输出文件】"><a href="#【输出文件】" class="headerlink" title="【输出文件】"></a><strong>【输出文件】</strong></h3><blockquote>
<p>输出文件为transform.out。</p>
<p>如果至少存在一个满足要求的变换序列 <em>T</em>，则输出文件中包含一行 <em>N</em> 个整数，表示你计算得到的字典序最小的 <em>T</em> ；否则输出”No Answer”（不含引号）。注意：输出文件中相邻两个数之间用一个空格分开，行末不包含多余空格。</p>
</blockquote>
<h3 id="【输入样例】"><a href="#【输入样例】" class="headerlink" title="【输入样例】"></a><strong>【输入样例】</strong></h3><blockquote>
<p>5</p>
<p>1 1 2 2 1</p>
</blockquote>
<h3 id="【输出样例】"><a href="#【输出样例】" class="headerlink" title="【输出样例】"></a><strong>【输出样例】</strong></h3><blockquote>
<p>1 2 4 0 3</p>
</blockquote>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>倒序二分图匹配，使用vector容器省空间省时间。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">int</span> lin[<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">bool</span> f[<span class="number">10005</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;a[<span class="number">10005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">flag</span><span class="params">(<span class="keyword">int</span> q,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> min(<span class="built_in">abs</span>(q-p),n-<span class="built_in">abs</span>(q-p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=a[x].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[a[x][i]])</span><br><span class="line">        &#123;</span><br><span class="line">            f[a[x][i]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(lin[a[x][i]]==<span class="number">-1</span>||dfs(lin[a[x][i]]))</span><br><span class="line">            &#123;</span><br><span class="line">                lin[a[x][i]]=x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("a.txt","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("b.txt","w",stdout);</span></span><br><span class="line">    <span class="comment">//freopen("transform.in","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("transform.out","w",stdout);</span></span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;dis[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x=i+dis[i];</span><br><span class="line">        <span class="keyword">int</span> y=i+n-dis[i];</span><br><span class="line">        x%=n;y%=n;</span><br><span class="line">        <span class="keyword">if</span>(flag(x,i)!=dis[i]) x=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(flag(y,i)!=dis[i]) y=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;y) swap(x,y);</span><br><span class="line">        <span class="keyword">if</span>(x!=<span class="number">-1</span>) a[i].push_back(x);</span><br><span class="line">        <span class="keyword">if</span>(y!=<span class="number">-1</span>) a[i].push_back(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(lin,<span class="number">-1</span>,<span class="keyword">sizeof</span>(lin));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">        <span class="keyword">if</span>(!dfs(i))</span><br><span class="line">        &#123;    </span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"No Answer"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout&lt;&lt;123456&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        ans[lin[i]]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,ans[i]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans[n<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图论</category>
        <category>二分图</category>
      </categories>
      <tags>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>【bzoj1798】Seq维护序列</title>
    <url>/2017/03/31/bzoj1798/</url>
    <content><![CDATA[<h3 id="描述-Description"><a href="#描述-Description" class="headerlink" title="描述 Description"></a>描述 Description</h3><blockquote>
<p>西行妖又开花了，于是幽灵们排着队到西行寺来观赏樱花，但可怕的是，幽幽子的结界在这个关键的时候却坏了，已经在庭院中的幽灵可以自由召唤自己熟识的幽灵，并且其他幽灵也可以自由从进入庭院。妖梦需要知道一段区间内幽灵的数量才可以放心使用【迷津慈航斩】来清理掉幽灵而不至于破坏庭院。于是她找到了Sakaki，但悲催的Sakaki月考考砸正在补作业，连自己喜欢的女孩都帮不了，所以他找到了你，希望你能解决这个问题。<br>庭院中的幽灵可以近似看做一条长度为N的线，因为幽灵没有实体所以在单位长度内可以有若干只幽灵，一段区间[ L , R ]内的幽灵可以同时作法，这时区间内的每只幽灵都会召来 C – 1 只幽灵，每只幽灵所召唤的幽灵都会落在自己所在的单位长度内，幽灵也会从天而降，在区间[ L , R ]内每单位区间落下C只幽灵。当妖梦要使用【迷津慈航斩】的时候，就会向你询问区间[ L , R ]内幽灵数的总和（ps 当然幽灵是灵体，是不会消失的，攻击只会使他们暂时迷惘），当然这个数会很大，你只需要输出这个数对5201314取模（膜）的值。</p>
</blockquote><a id="more"></a>
<ul>
<li><p><strong>去tmd垃圾题面</strong></p>
</li>
<li><p><strong>区间加法</strong> </p>
</li>
<li><p><strong>区间乘法</strong> </p>
</li>
<li><p><strong>维护区间和输出取膜</strong></p>
</li>
</ul>
<h3 id="输入格式-Input-Format"><a href="#输入格式-Input-Format" class="headerlink" title="输入格式 Input Format"></a>输入格式 Input Format</h3><blockquote>
<p>第一行为两个整数N和M<br>N为幽灵队列的长度，M为操作的次数<br>接下来有N个数，第i个数表示第i个单位长度内最初有几个幽灵<br>从第三行开始每行有一个操作<br>操作1：“1 L R C” 区间[ L , R ]内每只幽灵召唤C-1只幽灵在自己的单位长度内；<br>操作2：“2 L R C”区间[ L, R ]内每单位区间增加C只幽灵；<br>操作3：“3 L R”查询区间[ L, R ]内幽灵数量的总和模5201314的值<br>同一行相邻两数之间用一个空格隔开，每行开头和末尾没有多余空格。</p>
</blockquote>
<h3 id="输出格式-Output-Format"><a href="#输出格式-Output-Format" class="headerlink" title="输出格式 Output Format"></a>输出格式 Output Format</h3><blockquote>
<p>对每个操作3，按照它在输入中出现的顺序，依次输出一行一个整数表示询问结果。</p>
</blockquote>
<h3 id="样例输入-Sample-Input"><a href="#样例输入-Sample-Input" class="headerlink" title="样例输入 Sample Input"></a>样例输入 Sample Input</h3><blockquote>
<p>7 5<br>1 2 3 4 5 6 7<br>1 2 5 5<br>3 2 4<br>2 3 7 9<br>3 1 3<br>3 4 7</p>
</blockquote>
<h3 id="样例输出-Sample-Output"><a href="#样例输出-Sample-Output" class="headerlink" title="样例输出 Sample Output"></a>样例输出 Sample Output</h3><blockquote>
<p>45<br>35<br>94</p>
</blockquote>
<p>线段树模板题…</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> L(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R(x) (x&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2100000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> intt long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mo 5201314</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">intt ax,ay,x,y,q,c;</span><br><span class="line">intt n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qaq</span>&#123;</span></span><br><span class="line">    intt maxx,deladd;</span><br><span class="line">    intt delx;</span><br><span class="line">&#125;tree[maxn*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">intt <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    intt f=<span class="number">1</span>;</span><br><span class="line">    intt k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">while</span>(c&gt;<span class="string">'9'</span>||c&lt;<span class="string">'0'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>;</span><br><span class="line">        c=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">        k=(k&lt;&lt;<span class="number">3</span>)+(k&lt;&lt;<span class="number">1</span>)+c-<span class="string">'0'</span>;</span><br><span class="line">        c=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f*k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(intt id,intt l,intt r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[id].delx==<span class="number">1</span>&amp;&amp;tree[id].deladd==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    intt tad=tree[id].deladd;</span><br><span class="line">    intt txx=tree[id].delx;</span><br><span class="line">    intt mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    tree[L(id)].deladd=(tree[L(id)].deladd*txx+tad)%mo;</span><br><span class="line">    tree[R(id)].deladd=(tree[R(id)].deladd*txx+tad)%mo;</span><br><span class="line">    tree[L(id)].delx=(tree[L(id)].delx*txx)%mo;</span><br><span class="line">    tree[R(id)].delx=(tree[R(id)].delx*txx)%mo;</span><br><span class="line">    tree[L(id)].maxx=(tree[L(id)].maxx*txx+(mid-l+<span class="number">1</span>)*tad)%mo;</span><br><span class="line">    tree[R(id)].maxx=(tree[R(id)].maxx*txx+(r-(mid+<span class="number">1</span>)+<span class="number">1</span>)*tad)%mo;</span><br><span class="line">    tree[id].deladd=<span class="number">0</span>;</span><br><span class="line">    tree[id].delx=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(intt l,intt r,intt id,intt v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;y||r&lt;x) <span class="keyword">return</span>;</span><br><span class="line">    tree[id].delx=<span class="number">1</span>;</span><br><span class="line">    tree[id].deladd=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y)&#123;</span><br><span class="line">        tree[id].maxx=v;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;v&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    intt mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(l,mid,L(id),v);</span><br><span class="line">    build(mid+<span class="number">1</span>,r,R(id),v);</span><br><span class="line">    tree[id].maxx=(tree[L(id)].maxx+tree[R(id)].maxx)%mo;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;tree[id].maxx&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updatax</span><span class="params">(intt l,intt r,intt id,intt v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;y||r&lt;x) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y)&#123;</span><br><span class="line">        tree[id].deladd=(tree[id].deladd*v)%mo;</span><br><span class="line">        tree[id].delx=(tree[id].delx*v)%mo;</span><br><span class="line">        tree[id].maxx=(tree[id].maxx*v)%mo;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(id,l,r);</span><br><span class="line">    intt mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    updatax(l,mid,L(id),v);</span><br><span class="line">    updatax(mid+<span class="number">1</span>,r,R(id),v);</span><br><span class="line">    tree[id].maxx=(tree[L(id)].maxx+tree[R(id)].maxx)%mo;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updataadd</span><span class="params">(intt l,intt r,intt id,intt v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;y||r&lt;x) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y)&#123;</span><br><span class="line">        tree[id].deladd=(tree[id].deladd+v)%mo;</span><br><span class="line">        tree[id].maxx=(tree[id].maxx+(r-l+<span class="number">1</span>)*v)%mo;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(id,l,r);</span><br><span class="line">    intt mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    updataadd(l,mid,L(id),v);</span><br><span class="line">    updataadd(mid+<span class="number">1</span>,r,R(id),v);</span><br><span class="line">    tree[id].maxx=(tree[L(id)].maxx+tree[R(id)].maxx)%mo;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">intt <span class="title">findit</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;y||r&lt;x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y)&#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;tree[id].</span></span><br><span class="line">        <span class="keyword">return</span> tree[id].maxx%mo;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(id,l,r);</span><br><span class="line">    intt mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    intt t1=findit(l,mid,L(id));</span><br><span class="line">    intt t2=findit(mid+<span class="number">1</span>,r,R(id));</span><br><span class="line">    <span class="keyword">return</span> (t1+t2)%mo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("a.txt","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("b.txt","w",stdout);</span></span><br><span class="line">    <span class="built_in">memset</span>(tree,<span class="number">0</span>,<span class="keyword">sizeof</span>(tree));</span><br><span class="line">    n=read();</span><br><span class="line">    m=read();</span><br><span class="line">    <span class="comment">//cout&lt;&lt;n&lt;&lt;' '&lt;&lt;m&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        c=read();</span><br><span class="line">        x=y=i;</span><br><span class="line">        build(<span class="number">1</span>,n,<span class="number">1</span>,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        q=read();</span><br><span class="line">        ax=read();</span><br><span class="line">        ay=read();</span><br><span class="line">        <span class="keyword">if</span>(q==<span class="number">1</span>)&#123;</span><br><span class="line">            x=ax;</span><br><span class="line">            y=ay;</span><br><span class="line">            c=read();</span><br><span class="line">            updatax(<span class="number">1</span>,n,<span class="number">1</span>,c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(q==<span class="number">2</span>)&#123;</span><br><span class="line">            x=ax;</span><br><span class="line">            y=ay;</span><br><span class="line">            c=read();</span><br><span class="line">            updataadd(<span class="number">1</span>,n,<span class="number">1</span>,c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            x=ax;</span><br><span class="line">            y=ay;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;findit(<span class="number">1</span>,n,<span class="number">1</span>)%mo&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;"Runtime:"&lt;&lt;double(1.0*clock()/1000.0)&lt;&lt;"S!"&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>CEOI售票系统</title>
    <url>/2017/03/28/jzyzj1245/</url>
    <content><![CDATA[<h3 id="描述-Description"><a href="#描述-Description" class="headerlink" title="描述 Description"></a>描述 Description</h3><blockquote>
<p>某次列车途经C个城市，城市编号依次为1到C，列车上共有S个座位，铁路局规定售出的车票只能是坐票， 即车上所有的旅客都有座。售票系统是由计算机执行的，每一个售票申请包含三个参数，分别用O、D、N表示，O为起始站，D为目的地站，N为车票张数。售票 系统对该售票申请作出受理或不受理的决定，只有在从O到D的区段内列车上都有N个或N个以上的空座位时该售票申请才被受理。请你写一个程序，实现这个自动 售票系统。</p>
</blockquote><a id="more"></a>
<h3 id="输入格式-Input-Format"><a href="#输入格式-Input-Format" class="headerlink" title="输入格式 Input Format"></a>输入格式 Input Format</h3><blockquote>
<p>第一行包含三个用空格隔开的整数C、S和R，其中$1≤C≤60000$， $l≤S≤60000$，$1≤R≤60000$。C为城市个数，S为列车上的座位数，R为所有售票申请总数。接下来的R行每行为一个售票申请，用三个由空格隔开的整数O，D和N表示，O为起始站，D 为目的地站，N为车票张数，其中$1≤D≤C$，$1≤O≤C$，所有的售票申请按申请的时间从早到晚给出。</p>
</blockquote>
<h3 id="输出格式-Output-Format"><a href="#输出格式-Output-Format" class="headerlink" title="输出格式 Output Format"></a>输出格式 Output Format</h3><blockquote>
<p>输出共有R行，每行输出一个“YES”或“NO”，表示当前的售票申请被受理或不被受理。</p>
</blockquote>
<h3 id="样例输入-Sample-Input"><a href="#样例输入-Sample-Input" class="headerlink" title="样例输入 Sample Input"></a>样例输入 Sample Input</h3><blockquote>
<p>4 6 4<br>1 4 2<br>1 3 2<br>2 4 3<br>1 2 3</p>
</blockquote>
<h3 id="样例输出-Sample-Output"><a href="#样例输出-Sample-Output" class="headerlink" title="样例输出 Sample Output"></a>样例输出 Sample Output</h3><blockquote>
<p>YES<br>YES<br>NO<br>NO</p>
</blockquote>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这道题也很好思考，对每个数据先updata然后search，如果返回的值大于座位数，那么就把刚刚的票取消，即updata的偏移量，记录值为负数</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 60100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> L(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R(x) (x&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF -200000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,s,k;</span><br><span class="line"><span class="keyword">int</span> ax,ay,x,y,t;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qaq</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> maxx;</span><br><span class="line">    <span class="keyword">int</span> delta;</span><br><span class="line">&#125;tree[maxn*<span class="number">4</span>];</span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findit</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid,tl,tr;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;r||y&lt;l) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y) <span class="keyword">return</span> tree[root].maxx;</span><br><span class="line">    mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> temp=tree[root].delta;</span><br><span class="line">    tree[L(root)].delta+=temp;</span><br><span class="line">    tree[L(root)].maxx+=temp;</span><br><span class="line">    tree[R(root)].maxx+=temp;</span><br><span class="line">    tree[R(root)].delta+=temp;</span><br><span class="line">    tree[root].delta=<span class="number">0</span>;</span><br><span class="line">    tl=findit(l,mid,L(root));</span><br><span class="line">    tr=findit(mid+<span class="number">1</span>,r,R(root));</span><br><span class="line">    <span class="keyword">return</span> max(tl,tr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updatait</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;r||y&lt;l) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y)&#123;</span><br><span class="line">        tree[root].maxx+=t;</span><br><span class="line">        tree[root].delta+=t;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> temp=tree[root].delta;</span><br><span class="line">    tree[L(root)].delta+=temp;</span><br><span class="line">    tree[L(root)].maxx+=temp;</span><br><span class="line">    tree[R(root)].maxx+=temp;</span><br><span class="line">    tree[R(root)].delta+=temp;</span><br><span class="line">    tree[root].delta=<span class="number">0</span>;</span><br><span class="line">    mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    updatait(l,mid,L(root));</span><br><span class="line">    updatait(mid+<span class="number">1</span>,r,R(root));</span><br><span class="line">    tree[root].maxx=max(tree[L(root)].maxx,tree[R(root)].maxx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("a.txt","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("b.txt","w",stdout);</span></span><br><span class="line">    <span class="built_in">memset</span>(tree,<span class="number">0</span>,<span class="keyword">sizeof</span>(tree));</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;s&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;ax,&amp;ay,&amp;t);</span><br><span class="line">        x=ax;</span><br><span class="line">        y=ay<span class="number">-1</span>;</span><br><span class="line">        updatait(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans=findit(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ans&lt;=s) <span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            t=-t;</span><br><span class="line">            updatait(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>【jzyz-p1136】超车</title>
    <url>/2017/01/20/jzyzj1136/</url>
    <content><![CDATA[<p>这道题从看到它开始到做出来，已经过了快两周【因为第一次思路完全跑偏写的是暴力模拟想水过】</p><p>题意是这样的：</p><a id="more"></a>

<blockquote>
<p>jzabc除了对多米诺骨牌感兴趣外，对赛车也很感兴趣。上个周末他观看了一场赛车比赛。他总是能想出许多稀奇的问题。某一时刻，他看到有n辆车（总是匀速行驶）在同一直线上，并且处在一个无限长度的直道上，而且n辆车有严格的先后之分。他通过特殊的器材测出了每一辆车的速度。那么问题出现了，如果有两辆车A车和B车，A车在B车的后面，并且A车的速度比B车的快，那么经过一段时间后，A车一定会超过B车。我们称之为一次超车。那么他想请你帮忙计算超车总数。我们记车道起点的坐标为0。没有两辆车的坐标相同。</p>
</blockquote>
<p>输入：</p>
<blockquote>
<p>第一行，一个数n，车辆总数。</p>
<p>第二行至第n+1行，为n辆车的信息<br>每行有两个正整数x，y，x和y之间有一个空格<br>x为车的坐标，y为车的速度<br>$0&lt;x, y&lt;=1000000000$</p>
</blockquote>
<p>输出：</p>
<blockquote>
<p>超车总数【逆序对个数】</p>
</blockquote>
<p>先说说我第一次没看书理解的题意：开一个结构体，按坐标从小到大sort记录位次，然后sort按速度排序，用总数减去每次的位次，然后累加。后来发现如果速度大的在前次大的数不可能超过，而记录它之前的车总数-1不管从时间上还是从策略上都很难满足【已经按速度排序不可能从1循环到这辆车】。</p>
<p>然后从书上看到了这道题，本来准备看代码试一下，然后yyx同学告诉我这个代码完全是个bug，我就信了，根本不敢打，事实上证明书上的代码是正确的orz</p>
<p>事实证明自己努力想一些东西还是好的。解题思路大概就是将序列分开然后排序，然后把两个排过的合并。因为两边的序列有序，那么在一边选取的数和另一边比较，前面的数肯定全</p>
<p>都是逆序的。将排序和统计同时进行，不会影响最终答案。</p>
<p><strong>ps：注意统计数据量…会爆掉int</strong></p>
<p>下面放代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qaq</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line">qaq car[<span class="number">300100</span>];</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">300100</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">300100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mycmp</span><span class="params">(qaq a,qaq b)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> a.x&lt;b.x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;car[i].x,&amp;car[i].y);</span><br><span class="line">    sort(car+<span class="number">1</span>,car+<span class="number">1</span>+n,mycmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        a[i]=car[i].y;</span><br><span class="line">    <span class="comment">//for(int i=1;i&lt;=n;i++) cout&lt;&lt;a[i]&lt;&lt;' '; cout&lt;&lt;endl&lt;&lt;"----------------";</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,mid,temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(l+<span class="number">1</span>&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        work(l,mid<span class="number">-1</span>);</span><br><span class="line">        work(mid,r);</span><br><span class="line">        temp=l;</span><br><span class="line">        <span class="keyword">for</span>(i=l,j=mid;(i&lt;=mid<span class="number">-1</span>)&amp;&amp;(j&lt;=r);)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;a[j])</span><br><span class="line">            &#123;</span><br><span class="line">                c[temp++]=a[j++];</span><br><span class="line">                ans+=mid-i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> c[temp++]=a[i++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(j&lt;=r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(;j&lt;=r;j++) c[temp++]=a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(;i&lt;=mid<span class="number">-1</span>;i++) c[temp++]=a[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++) a[i]=c[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(l+<span class="number">1</span>==r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[l]&gt;a[r])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tt=a[r];</span><br><span class="line">                a[r]=a[l];</span><br><span class="line">                a[l]=tt;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    work(<span class="number">1</span>,n);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>归并排序</category>
      </categories>
      <tags>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title>2016NOIP总结</title>
    <url>/2016/12/07/2016NOIP/</url>
    <content><![CDATA[<p>从暑假开始学OI到现在，也已经过了4个月。说实话真是快啊…感觉没学什么东西就要去比赛了。怎么说呢，感觉自己真的是个菜鸡啊为什么就要去比赛呢。当初来到这里，是凭着兴趣来的，第一天能打那么多道题（19道吧好像…）（当然听说紫萱学姐那么nb我就自愧不如了QAQ）我也是很吃惊的，虽然后来没这么快过了…只能说这也是积累的过程吧。毕竟当初自己这种菜鸡循环都不会，一个if语句都写不过。至今我还记得当初一元二次方程那道题是从别人那里复制的..打了一个上午都是错的有木有QAQ。</p><a id="more"></a>
<p>然后成绩吧…….说实话真的是炸了。我是真的没考这么烂过。年级601（加红一下表示这个成绩让我瞎了）……………..当时看到我整个人其实都是懵逼的。我可以说这是我从小到大最烂的名次了。不过这也怪自己，自己努力了多少，我自己也是清\楚的，考到这个成绩也是咎由自取，怪不得别人。每天浮躁也不少嘛…所以说都是自己作死_(:зゝ∠)_。</p>
<p>周六比赛，我除了扫了一眼弗洛里德，好像没怎么看过书。但是好像考试看了也没啥用了，自己会做的也差不多都写了。</p>
<p>OI的路也才刚刚开始。</p>
<p><strong>那接下来说说题吧：</strong></p>
<h3 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h3><h4 id="T1：toy"><a href="#T1：toy" class="headerlink" title="T1：toy"></a>T1：toy</h4><p>这题挺水的…开两个bool判定左右和里外，然后字符串数组存名字，直接模拟就行了。而且给定的左右还不会超过人数，只用判定一次头尾就行了。</p>
<p>目测能AC；</p>
<h4 id="T2：running"><a href="#T2：running" class="headerlink" title="T2：running"></a>T2：running</h4><p>QAQ这题真的是有毒。根本没学过树的表示这道题我不会，看了看数据。。只能水前4组。有3个数据的是链不是树，但是想了想只会10w*10w的双重循环，而且这数据是n=99994还不是n&lt;=99994…..于是完蛋了<em>(:зゝ∠)\</em></p>
<p>目测20分吧…</p>
<h4 id="T3：classroom"><a href="#T3：classroom" class="headerlink" title="T3：classroom"></a>T3：classroom</h4><p>写这道题的时候已经没多少时间了。大概粗略看了看题和数据量。最短路径问题还&lt;400这不是弗洛伊德随便搞吗？但是求的是期望值（换了之后耗费的体力 X 换课成功的概率 全部情况加起来）还是最小期望值，但是看了看时间明显没时间给我想了….挺后悔第二题我有点贪想多拿点，结果这道题好像还简单一些。没办法只能水前两组数据，只有一堂课和只有两间教室还没机会换的。结果出来发现没机会换代表期望值还是1！！！！！就是要输出路程…orz第一个数据不确定是0.00还是0，这道题也就完了…..</p>
<p>目测爆零QAQ</p>
<h3 id="DAY2"><a href="#DAY2" class="headerlink" title="DAY2"></a>DAY2</h3><h4 id="T1：problem"><a href="#T1：problem" class="headerlink" title="T1：problem"></a>T1：problem</h4><p>恩….第一题…..怀着AC的愿望却发现还可能爆0QAQ，真是太打击人了。推了下发现阶乘这玩意超过40long long就能给爆掉，没办法只能照着前10组打暴力。</p>
<p>然后考完发现我存的时候开的是int数组！！！！！！！！！！嗷嗷完蛋了，这下能水的就更少了QAQ</p>
<p>目测10~40分吧。。。运气不好估计就爆0；</p>
<h4 id="T2：earthworm"><a href="#T2：earthworm" class="headerlink" title="T2：earthworm"></a>T2：earthworm</h4><p>为什么要切蚯蚓，这是残害可爱的小动物啊…oAo，毫无人性。但是做题嘛…恩等等，有14组数据都是切一半，70分。。也就照着这个打了暴力模拟。但是没有想到用堆（用了你也打错），感觉如果数据不水了会因为sort太多超时…</p>
<p>这就看我攒的人品了….应该15~70（想多了）</p>
<h4 id="T3：angrybirds"><a href="#T3：angrybirds" class="headerlink" title="T3：angrybirds"></a>T3：angrybirds</h4><p>为什么会有愤怒的小鸟，打猪搞二次函数还要正中，于是这是两个质点的碰撞吗….</p>
<p>好吧这道题根本没有时间了<em>(:зゝ∠)</em>…………0分妥妥的</p>
<p>所以最后应该成绩在145~230………啊我果然是菜鸡QAQ……………..</p>
<p>以后应该努力了，CS打23/5我也不是大神对吧…….不过今年也就这样了。</p>
<p>来年再战吧，只要相信自己，你就能变得更强。</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
</search>
